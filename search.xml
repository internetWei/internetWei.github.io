<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>浅谈C语言的陷进</title>
      <link href="/2022/07/22/%E6%85%8E%E7%94%A8unsigned%E7%B1%BB%E5%9E%8B/"/>
      <url>/2022/07/22/%E6%85%8E%E7%94%A8unsigned%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<!-- > 由布多(budo)发布于 2023年10月26日 • 最后更新：2023年10月29日 --><p>这篇文章我会从计算机基础的角度向大家解释 unsigned 类型 和 signed 类型在内存中到底是如何存储的，以及为什么要慎用 unsigned 类型。</p><blockquote><p>我是站在 iOS 开发角度写的这篇文章，所以会出现一些OC代码，如果你看不懂的话可以跳过这些部分。</p></blockquote><p>在OC中我们一般会使用 <strong>NSUInteger</strong> 而非 <strong>unsigned</strong> 表示无符号整数，但其实它们是一样的，NSUInteger 只是 unsigned 的类型别名而已；NSObjCRuntime.h 文件中有关于 NSUInteger 的详细定义。</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> __LP64__ || TARGET_OS_WIN32 || NS_BUILD_32_LIKE_64</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="built_in">NSUInteger</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="built_in">NSUInteger</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)reversePrintObjectWithArray:(<span class="built_in">NSArray</span> *)array &#123;</span><br><span class="line">    <span class="keyword">if</span> (![array isKindOfClass:<span class="built_in">NSArray</span>.class]) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = array.count - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;第%lu个元素: %@&quot;</span>, i, array[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个方法只是简单的倒序打印数组中的每个元素，而且在打印前也做了类型检查和判空操作。但是它还是有问题，你能看出来吗？</p><p>当你传递的参数是 nil、非 NSArray 类型，或者非空数组时，一切都正常；但如果你不小心传递了一个空数组，将会导致崩溃，崩溃原因是数组访问越界，越界的索引是 18446744073709551615(<code>如果在32位环境下，会是4294967295</code>)。你也可以把这段代码粘贴到你的项目中，测试一下看看结果是否和我说的一样。</p><p>？？？是不是觉得条件都不符合，循环应该一次都没执行，还有 18446744073709551615 是哪来的？</p><p>其实造成这一切的根源在于 __计算机对于正数和负数的读写方式不一样__。</p><hr><p>下面我将用C代码来帮助大家理解 _计算机是如何读写正数和负数_。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">short</span> a = <span class="number">-18</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> b = <span class="number">65518</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a: %hd, %hu\n&quot;</span>, a, a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;b: %hd, %hu\n&quot;</span>, b, b);</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/internetWei/files/master/Images/2022_07_20_16.37.50.png" alt="运行结果"></p><p>计算机规定整数必须以补码形式进行存储，如果你想弄明白为什么，请阅读<a href="#jump1">题外话(为什么要使用补码)</a>。</p><blockquote><p>注意：只有负数需要计算补码，正数的反码、补码其实和原码一样。</p></blockquote><p>变量a的补码计算过程如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-18</span><br><span class="line">= 10010(18的二进制)</span><br><span class="line">= 0000 0000 0001 0010(short 类型占用 2 * 8 = 16 个比特位，所以前面需要补0)</span><br><span class="line">= 1000 0000 0001 0010(计算机规定，有符号数的第1个比特位用于存储符号位，1表示负</span><br><span class="line">数，0表示正数；这就是-18的原码)</span><br><span class="line">= 1111 1111 1110 1101(这是-18的反码，反码就是把除符号位之外的所有数据取反)</span><br><span class="line">= 1111 1111 1110 1110(这是-18的补码，补码是在反码的基础上加1)</span><br></pre></td></tr></table></figure><p>变量a实际存储在内存中的数据不是原码 <code>1000 0000 0001 0010</code> 而是补码 <code>1111 1111 1110 1110</code>；在使用 <code>%hd</code> 打印的时候，计算机会把内存中的数据当作补码处理，所以需要先将它还原成原码 <code>1000 0000 0001 0010</code>，然后把原码转为十进制，所以输出的是 -18。</p><p>当你使用 <code>%hu</code> 去打印变量a的时候，计算机会把这块内存的数据解释为正数，还记得之前提到的正数的补码和原码一样吗，计算机会把内存中的数据直接当作原码处理， <code>1111 1111 1110 1110</code> 转为十进制正好就是 65518 。</p><p>看完变量a的讲解后，你是否能手动验证变量b的结果呢？</p><p>变量b的原码是 <code>1111 1111 1110 1110</code>，由于它是正数，所以补码就等于原码；在使用 <code>%hu</code> 打印的时候，计算机会把内存中的数据直接当成原码处理，所以会输出 65518。</p><p>如果使用 <code>%hd</code> 打印的话，计算机会把内存中的数据当做补码，补码转为原码是 <code>1000 0000 0001 0010</code>，发现了吗，这不就是 -18 的原码吗。</p><blockquote><p>发现了吗，65518 的补码&#x2F;原码正好和 -18 的补码一样(<code>简单的说，在内存中 65518 和 -18 的数据是一样的</code>)；有时候现实中2个完全不同的数可能在内存中的表现会一模一样，这也是为什么大部分情况下二进制无法还原回高级语言的原因。</p></blockquote><blockquote><p>以变量a为例，不管它的类型是 <code>short</code> 还是 <code>unsigned short</code>，都不会影响 -18 这个值在内存中的存储方式，在读取变量a的值时，计算机首先找到变量a的地址，然后根据类型得到它的长度，short 的长度是 2 * 8 &#x3D; 16 个比特位，从变量a的地址开始，往后16个比特位就是变量a在内存中存储的数据，使用不同的符号打印(%hu、%hd)会影响计算机对这块内存的解释，但不会影响内存中的数据。</p></blockquote><hr><p>回到开头那个数组越界的问题，18446744073709551615 其实就是把 -1 当作无符号数读取而来的。</p><p>由于 <code>NSUInteger</code> 实际是 long 类型，占用 <code>8 * 8 = 64</code> 个比特位，-1 的原码是 <code>1000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0001</code>，补码是 <code>1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111</code>，由于 <code>NSUInteger</code> 是无符号数，所以计算机会把补码当成原码使用，转为十进制正好就是 18446744073709551615 。</p><p>解决起来也很简单，把 <code>NSUInteger</code> 用 <code>NSInteger</code> 代替就行了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在项目开发过程中，除了返回值、参数等特殊地方，建议统一使用有符号数(<code>NSInteger</code>)代替无符号数(<code>NSUInteger</code>)，这有如下好处：</p><ol><li>提高代码的统一性和兼容性。</li><li>避免不同数字类型之间的转换问题，减少代码复杂度，降低代码BUG率。</li></ol><p>如果必须要使用无符号数，例如返回值、参数等，切记一定要在使用前检查数据正确性，例如使用强转判断值是否正确。</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 无符号数作为方法参数</span></span><br><span class="line">- (<span class="type">void</span>)fun:(<span class="built_in">NSUInteger</span>)index &#123;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">NSInteger</span>)index &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无符号数作为返回值</span></span><br><span class="line"><span class="built_in">NSInteger</span> _count;</span><br><span class="line">- (<span class="built_in">NSUInteger</span>)count &#123;</span><br><span class="line">    <span class="keyword">return</span> _count &lt; <span class="number">0</span> ? <span class="number">0</span> : (<span class="built_in">NSUInteger</span>)_count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>像文章中的这种问题属于数据异常，大部分情况下数据异常远比崩溃还要严重。</p><p>数据异常可能会给用户或公司带来巨大损失；假设你开发一个计算器软件，把值算错了大概率会导致非常严重的后果和损失，如果让程序崩溃或死机，至少客户会选择其他计算器或计算方式而不会造成后面更严重的损失。</p><p>另外数据异常这种问题通常很难发现，很容易成为线上BUG导致糟糕的用户体验(<code>建议大家平常使用单元测试来对代码进行定期体检，这样能大大降低类似的这种错误</code>)。</p><p>在Swift中，如果你对一个无符号类型(<code>UInt</code>)变量不小心赋值了负数的话，将会得到一个运行时崩溃，说明数据异常确实比APP崩溃更严重。</p><h2 id="题外话-为什么要使用补码"><a href="#题外话-为什么要使用补码" class="headerlink" title="题外话(为什么要使用补码)"></a><span id = "jump1">题外话(为什么要使用补码)</span></h2><p>由于加法和减法这种操作非常频繁，为了提高运算效率，所以它们一般都由硬件直接支持；如果直接使用原码存储的话，在计算类似 <code>6 - 18</code> 这样的表达式时将会得到错误的结果：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6 - 18 = 6 + (-18)</span><br><span class="line">= 0000 0000 0000 0110(原) + 1000 0000 0001 0010(原)</span><br><span class="line">= 1000 0000 0001 1000(原)</span><br><span class="line">= -24</span><br></pre></td></tr></table></figure><p>很明显计算结果是不对的，于是有些人设计出了反码，用反码计算确实解决了 <code>6 - 18</code> 的问题，但是类似 <code>18 - 6</code> 这样的计算又出错了：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">18 - 6 = 18 + (-6)</span><br><span class="line">= 0000 0000 0001 0010(原) + 0000 0000 0000 0110(原)</span><br><span class="line">= 0000 0000 0001 0010(反) + 1111 1111 1111 1001(反)</span><br><span class="line">= 1 0000 0000 0000 1011(反) </span><br><span class="line">= 0000 0000 0000 1011(反) // 最左边的1内存容纳不了，所以直接截掉。</span><br><span class="line">= 0000 0000 0000 1011(原)</span><br><span class="line">= 11</span><br></pre></td></tr></table></figure><p>计算结果离正确值还差1，__如果按照反码计算的话，小数减去大数会正确，但大数减去小数就始终会相差1__，还是那群人，又绞尽脑汁的设计出了补码(<code>该设计者因此获得了图灵奖</code>)。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">18 - 6 = 18 + (-6)</span><br><span class="line">= 0000 0000 0001 0010(原) + 0000 0000 0000 0110(原)</span><br><span class="line">= 0000 0000 0001 0010(反) + 1111 1111 1111 1001(反)</span><br><span class="line">= 0000 0000 0001 0010(补) + 1111 1111 1111 1010(补)</span><br><span class="line">= 1 0000 0000 0000 1100(补)</span><br><span class="line">= 0000 0000 0000 1100(补) // 最左边的1内存容纳不了，所以直接截掉。</span><br><span class="line">= 0000 0000 0000 1100(反)</span><br><span class="line">= 0000 0000 0000 1100(原)</span><br><span class="line">= 12</span><br></pre></td></tr></table></figure><p>结果终于正确了，如果大家感兴趣的话可以手动计算一下 <code>13 - 5</code>、<code>5 - 13</code> 等等来巩固你学到的知识。</p><blockquote><p>计算机的设计是一门艺术，很多实用的技术都是权衡和妥协的结果。</p></blockquote><p>如果你还是不理解的话，建议你看看 <a href="http://c.biancheng.net/view/vip_1761.html">整数在内存中是如何存储的，为什么它堪称天才般的设计</a>(<code>这是一篇付费文章，如果你不想付费的话请自行百度搜索关键字</code>)。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>不要把无符号数、有符号数和正数、负数搞混，无符号数肯定是正数，但有符号数未必是负数。</p><p>计算机是对正数和负数的读写规则不一样，不是对无符号数和有符号数的读写规则不一样。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序员 </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>struct的内存对齐</title>
      <link href="/2022/07/09/%E4%B8%80%E6%96%87%E8%AF%BB%E6%87%82%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/"/>
      <url>/2022/07/09/%E4%B8%80%E6%96%87%E8%AF%BB%E6%87%82%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/</url>
      
        <content type="html"><![CDATA[<blockquote><p>由布多(budo)发布于 2022年7月9日 • 最后更新：2023年11月1日</p></blockquote><blockquote><p>运行环境：macOS 14.0<br>编译工具：Xcode 15.0</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">关于 struct 内存对齐的文章网上已经有很多了，但大部分文章都讲的不清不楚；该文章只是一份笔记，用于记录我学习 struct 内存对齐的过程。</span><br></pre></td></tr></table></figure><p>虽然原理很简单，但为了讲清楚，还是花了我一天的时间，真的大大超乎我的意料。</p><p>关于什么是内存对齐？以及为什么要内存对齐，这里不再重复，网上有很多资料，请自行搜索。</p><p>该文章以 struct 为基础。内存对齐分为内对齐和外对齐。先将 struct 中所有元素进行内对齐，最后再对 struct 进行外对齐。</p><h2 id="什么是内存对齐"><a href="#什么是内存对齐" class="headerlink" title="什么是内存对齐"></a>什么是内存对齐</h2><p>计算机的内存空间都是按照字节划分的，从理论上讲似乎对任何类型的变量都可以从任何地址开始，但实际上计算机系统对基本类型数据在内存中存放的位置是有限制的，它们会要求这些数据的首地址是某个数k(<code>64位环境下通常是8</code>)的倍数，这就是所谓的内存对齐。</p><h2 id="为什么要进行内存对齐"><a href="#为什么要进行内存对齐" class="headerlink" title="为什么要进行内存对齐"></a>为什么要进行内存对齐</h2><p>简单的说就是有空间换时间。<br>尽管内存是以字节为单位，但是大部分处理器并不是按照一个字节一个字节来存取内存的，它一般会以双字节、4字节、8字节、16字节甚至32字节为单位进行存取内存，我们将上述这些存取单位称为内存存取粒度。</p><p>假设现在有一台 64 位系统的处理器，该处理器只能从地址为8的倍数的内存开始读取数据。</p><p>假如没有内存对齐机制，数据可以任意存放，现在有一个 double 变量存放从地址1开始的连续8个字节中，该处理器去取数据时，要先从0地址开始读取第一个8字节块，剔除不想要的字节(0字节)，然后从地址8开始读取下一个8字节块，同样剔除不要的数据(9…15)，最后留下的两块数据合并放入寄存器，这需要做很多工作。</p><p>简单的说内存对齐能够提高 cpu 读取数据的速度，减少 cpu 访问数据的出错性。</p><p>现在有了内存对齐，double 类型数据只能存放在按照对齐规则的内存中，比如说0地址开始的内存，那么现在该处理器在取数据时一次性就能将数据读出来了，而且不需要额外的操作，提高了效率。</p><blockquote><p>为什么必须是8的倍数？因为64位处理器一次最多可以处理8个字节的数据，如果读取少于8个字节的数据，那么就浪费，多了也没有用。这样可以以最快的速度寻址，不遗漏一个字节，也不重复对一个字节寻址。</p></blockquote><h2 id="内存对齐规则"><a href="#内存对齐规则" class="headerlink" title="内存对齐规则"></a>内存对齐规则</h2><p>每个特定平台上的编译器都有自己的默认“对齐系数(<code>对齐模数</code>)”，64 位系统中默认是 8，可以通过 #pragma pack(n) 来改变，其中n可以是1、2、4、8、16。</p><p>对齐单位(<code>有效对齐值</code>)：是给定值 #pragma pack(n) 和结构体中最长数据类型长度较小的那个。</p><p>了解了上面的概念后，我们现在可以来看看内存对齐需要遵循的2条规则：</p><ol><li>内对齐规则：结构体第一个成员的偏移量为0，以后每个成员相对于结构体首地址的偏移量都是该成员大小与有效对齐值较小那个的整数倍，如有需要编译器会在成员之间加上填充字节。</li><li>外对齐规则：结构体的总大小为有效对齐的整数倍，如有需要编译器会在最末一个成员之后加上填充字节。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序员 </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git提交规范</title>
      <link href="/2022/01/20/Git%E6%8F%90%E4%BA%A4%E8%A7%84%E8%8C%83/"/>
      <url>/2022/01/20/Git%E6%8F%90%E4%BA%A4%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<!-- > 由布多(budo)发布于 2023年10月26日 • 最后更新：2023年10月29日 --> <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之所以制定Git提交规范，是因为公司内有很多人对提交信息和提交内容都不重视，具体表现在2个方面：</p><ol><li>提交信息随便写，例如 up、1。</li><li>提交内容很随意，什么时候想提交了就提交，经常一个提交会包含多个提交内容，例如新功能开发、BUG修复、文件夹结构调整等等经常包含在一个提交里。</li></ol><p>这篇文章对提交信息和提交内容这2个方面都制定了相关规范，最终目的如下：</p><ol><li>只需要浏览提交信息不用阅读提交内容即可知道此次提交做了什么。</li><li>每一个提交都是完整且独立的；<br>完整性体现在以后的任意时间回滚到此次提交都可以直接运行项目，<br>独立性体现在一个提交仅包含一个修改内容。</li></ol><p>制定实施以后效果非常好，所以稍微总结了一下并发表出来，希望能帮到大家提高效率。</p><p>实施以后部分好处如下：</p><ol><li>想对某1个版本进行整理，列出添加了哪些功能、修复了什么问题，之前需要手动查看每次提交的具体内容，然后记录下来，这个过程不仅耗时，而且极易出错；现在只需要将指定时间段内的提交信息打印出来，然后根据提交信息做一些简单的删除修改操作即可，不用去看具体的提交内容。</li><li>有时候某一个分支需要应用某一个功能，但是这个功能进行了多次提交，而且并不集中在一块；由于提交信息规范了，只需要利用 <code>git log --grep</code> 命名即可找出所有关于这个功能的提交，然后使用 <code>git cherry-pick</code> 命令应用即可。</li><li>考虑到文章长度，还有很多好处并没有列出……</li></ol><h2 id="提交内容规范"><a href="#提交内容规范" class="headerlink" title="提交内容规范"></a>提交内容规范</h2><ul><li><p><strong>[必须]</strong> 保证每次提交都是独立且完整的，鼓励多次数少内容提交。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">独立：</span><br><span class="line">通常情况下，一次提交只允许做一件事。</span><br><span class="line">完整：</span><br><span class="line">每次提交都必须保证它是完整的，具体表现为以后任意时间回滚到这个提交时都可以直接运行项目。</span><br><span class="line"></span><br><span class="line">小而独立的提交有以下好处：</span><br><span class="line">1. 审查比较快。</span><br><span class="line">2. 审查更彻底。</span><br><span class="line">3. 不太可能引入错误。</span><br><span class="line">4. 更容易合并。</span><br><span class="line">5. 如果它们被拒绝，可以减少浪费的工作。例如你写了一个巨大的CL，</span><br><span class="line">   然后你的审查人说总体方向是错误的，那么你就浪费了很多工作。</span><br><span class="line">6. 回滚更简单。</span><br><span class="line">7. ……</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 涉及文件夹结构、文件夹名称、基类代码或影响范围很大的修改尽量作为一次提交，不要分散提交，也不要和其他修改一起提交。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">有时候经常会出现开发一个功能时，突然要紧急修改一个BUG；</span><br><span class="line">这个时候你并不想提交当前的代码，因为这个功能还没有开发完；</span><br><span class="line">此时你有3种方式可以保证提交的独立性：</span><br><span class="line"></span><br><span class="line">1. 在当前分支上做一次临时提交，但是不要推送到远程，</span><br><span class="line">   切换到一个干净的新分支上修改BUG，待修改完成后再回到原先的分支，</span><br><span class="line">   使用 `git reset --mixed` 命令回到提交前的状态继续开发新功能。</span><br><span class="line">2. 使用 `git stash -u` 命令将当前工作区和暂存区的内容贮藏起来，</span><br><span class="line">   然后在当前分支或者新分支上修改BUG(建议在新分支上)，</span><br><span class="line">   待BUG修改完成后再使用 `git stash pop --index` 命令回到之前的工作状态。</span><br><span class="line">3. 直接在当前分支上修改BUG，</span><br><span class="line">   修改完成后使用 `git add -p` 命令精确的贮藏BUG修改的每条内容，然后提交；</span><br><span class="line">   除非你对 Git 十分了解，否则不建议你使用此方法，因为难度很大。</span><br></pre></td></tr></table></figure></li></ul><h2 id="提交信息规范"><a href="#提交信息规范" class="headerlink" title="提交信息规范"></a>提交信息规范</h2><ul><li><p><strong>[必须]</strong> 提交信息要达到即使是新人，在不看提交内容的情况下也能知道此次提交干了什么，关于提交信息的格式与规范请参考 <a href="http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html">Commitizen格式</a>。</p><p>  一个好例子：<br>  <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e7a514b753549b185a34245a806810a~tplv-k3u1fbpfcp-zoom-1.image"></p></li></ul><h2 id="其他规范"><a href="#其他规范" class="headerlink" title="其他规范"></a>其他规范</h2><ul><li><p><strong>[必须]</strong> 项目中创建Tag时统一使用附注Tag，附注Tag可以包含更多信息，方便后来人明白当初创建Tag的含义和作用。</p></li><li><p><strong>[建议]</strong> 不要养成提交就立即推送的习惯，有些工具会默认提交就推送，请关闭它；没有推送之前，提交只存在于你的本地Git库，你如果不满意之前的提交内容和提交信息，你可以修改它直到满意为止，但是如果你已经推送了就不能这么操作了。</p> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我们不是完人，有时候经常会遇到对之前提交的内容或提交信息不满意的地方想要修改，例如：</span><br><span class="line">1. 某次提交的提交信息这样写可能更好理解一些。</span><br><span class="line">2. 某次提交不小心漏提交了一个文件或一行代码。</span><br><span class="line">3. 某次提交不小心多添加了几个文件或几行代码，而这几行代码应该属于其他提交。</span><br><span class="line"></span><br><span class="line">我们经常会使用 `git commit --amend` 来修改上次的提交内容或提交信息，</span><br><span class="line">使用 `git rebase -i` 来修改历史提交内容或提交信息。</span><br><span class="line">但是这2个命令都会修改提交哈希值，如果修改前的提交仅存在于你的本地Git仓库，那这么做没有任何问题，</span><br><span class="line">如果你已经推送了这些提交，或者这些提交存在于其他地方，那么将会发生问题。</span><br><span class="line">简单的来说不要对任何已经推送的提交进行修改。</span><br><span class="line">如果你真的不小心这么做了，请告诉你的同事，在下次拉取代码的时候使用 `git pull --rebase` 代替 `git pull`，</span><br><span class="line">虽然这么做可能不能完全解决问题，但是可能会减少伤痛。</span><br></pre></td></tr></table></figure></li></ul><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><ol><li>可以转载，但是请注明来源。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Code Review规范</title>
      <link href="/2022/01/20/Code%20Review%E8%A7%84%E8%8C%83/"/>
      <url>/2022/01/20/Code%20Review%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<!-- > 由布多(budo)发布于 2023年10月26日 • 最后更新：2023年10月29日 --> <blockquote><p>本文的名词解释：</p><ul><li>CR：code review</li><li>CL：change list(指这次改动)</li></ul></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这篇文章是站在公司的角度基于 Google的代码审查指南 和笔者实际经验的个人总结，所以相对原文(Google的代码审查指南)有适当的删减，想看完整版的请阅读<a href="https://google.github.io/eng-practices/review/reviewer/">Google的代码审查指南</a>。</p><p>该规范的目的旨在提高公司内部项目的代码库质量。</p><h2 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h2><ol><li><p>技术事实和数据应该凌驾于意见和个人偏好之上；在代码风格方面，风格指南是绝对权威，任何不在指南中的点(如空格等)都是个人偏好的问题，这些点原则上应该与现有的风格保持一致，但是如果这些点现在还没有形成一定的风格，那么应该接受作者的风格。</p></li><li><p>软件设计的各个方面几乎从来不是纯粹的风格问题，也不只是个人偏好，它们是建立在基本原则的基础上的，应该在这些原则的基础上加以衡量，而不仅仅是只考虑个人意见。有时，如果作者能够证明(通过数据或基于可靠的工程原理)它的方法是同样有效的，那么审查者应该接受作者的偏好。否则，审查者的选择应该取决于软件设计的标准原则。</p></li></ol><h3 id="CR的标准"><a href="#CR的标准" class="headerlink" title="CR的标准"></a>CR的标准</h3><ol><li><p>Code Reivew的主要目的是确保代码库的 <strong>整体代码</strong> 运行状况随着 <strong>时间的推移</strong> 而 <strong>得到改善</strong>，Code Review的所有工具和流程都为此而设计。</p></li><li><p>为了实现这个目标，必须 <strong>综合考虑许多因素</strong>，并且做出 <strong>取舍和平衡</strong>。</p></li><li><p>审查者有责任确保每个CL都具有这样的质量：即随着时间的推移，代码库的整体代码健康状况不会降低。这可能会很棘手，特别是当团队的交付受到严重的时间限制并且他们觉得必须采取捷径才能实现目标时。</p></li><li><p>没有 <strong>完美</strong> 的代码，只有 <strong>更好的代码</strong>，审查者应该权衡发展的需要和别人的建议；不应该追求完美，而应追求持续改进，作为一个整体，如果CL能提高整个系统的可维护性、可读性、可理解性，那么不应该因为它不 “完美” 而拒绝。</p></li><li><p>如果开发人员有些地方做的很好，应该告诉并鼓励开发人员，但是如果这个改进不是很重要，可以告诉作者这种改进只是一种锦上添花的效果，作者可以选择忽略避免重复工作。</p></li></ol><h3 id="CR关注点"><a href="#CR关注点" class="headerlink" title="CR关注点"></a>CR关注点</h3><ol><li><p>在CR中最重要的是看CL的整体设计与结构。CL中不同代码段的交互是否有意义？它与系统的其他部分是否集成良好？现在是添加此功能的合适时机吗？</p></li><li><p>审查者应该按照 <a href="https://juejin.cn/post/7018484631057989663"><strong>风格指南</strong></a>、<a href="https://juejin.cn/post/7055164422662127647"><strong>开发规范</strong></a> 进行检查。</p></li><li><p>审查者应该考虑一些边缘状况，寻找并发性问题，尝试像用户一样思考，并确保不会看到仅通过阅读代码就能发现的错误。</p></li><li><p>审查者应该严查使用了设计模式的地方(例如使用了单例，那么就检查是否一定需要使用)。</p></li><li><p>如果有必要的话可以自己去验证CL。有些时候在阅读代码时，很难理解某些更改会对用户产生怎样的影响，例如UI更改。对于这样的更改，如果不方便自己测试，可以让开发人员演示该功能。</p></li><li><p>在CR期间另一个特别重要的事情是查看代码中是否存在某种 <strong>并发编程</strong>，理论上可能导致死锁或竞争条件，这些类型的问题很难通过运行代码来检测，通常需要有人(开发人员或审查者)仔细考虑它们以确保不会引入问题。</p></li></ol><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><ol><li><p>代码的复杂度是否超过预期？有没有更简单的实现方式？单行代码是否过于复杂？函数或方法是否过于复杂？类是否过于复杂？“复杂” 通常意味着该代码很难阅读，也意味着 “当开发人员试图调用或修改这段代码时，他们很可能会引入BUG”。</p></li><li><p>有一种复杂性是过度设计造成的，开发者让那段代码过度通用化，超过了原本所需要的，或者是增加了系统目前不需要的功能；审查者应特别注意一下过度设计，鼓励开发者解决他们现在需要解决的问题，而不是推测将来可能需要解决的问题，当那些问题出现的时候再去解决它们，因为那个时候你可以更清晰的看见问题的样子。</p></li></ol><h3 id="如何浏览CL"><a href="#如何浏览CL" class="headerlink" title="如何浏览CL"></a>如何浏览CL</h3><ol><li><p>用宏观的角度来看待改动，查看CL描述以及它做了什么。</p></li><li><p>找到CL最核心的部分文件，首先查看这些主要部分。这有助于为CL的其他较小部分提供逻辑，而且这样可以提高CR速度。如果CL太大导致无法确定哪里是主要部分时，请向开发者询问重要的部分，或者要求他们将CL拆分为多个CL。如果在主要部分发现存在主要的设计问题，应该立即告诉开发者修改。因为如果设计问题足够严重的话，继续CR其他部分的代码可能只是浪费时间。</p></li></ol><h3 id="浏览每一行代码"><a href="#浏览每一行代码" class="headerlink" title="浏览每一行代码"></a>浏览每一行代码</h3><ol><li><p>仔细审查每一行代码。有些东西，例如资料文件、生成的代码、大型数据结构，你可以稍微扫过，但是不要扫过开发者写的类、函数、方法、代码区块，更不能假设它内部是没问题的。</p></li><li><p>如果代码过于复杂并且需要减慢审查速度时，那么请你告诉开发者这件事，让他们为这段代码做出解释。你要求开发者去说清楚这段代码时，同时也在帮助未来的开发人员理解这些代码。</p></li></ol><h3 id="上下文"><a href="#上下文" class="headerlink" title="上下文"></a>上下文</h3><ol><li>请结合上下文查看CL，该CL是否改善了整体系统的代码质量，会不会让整个系统更加复杂？是否缺少测试？千万不要授受会降低整体系统代码质量的CL。因为大多数系统是由于许多小改动的累积而变得复杂的。</li></ol><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><ol><li><p>一般来说，测试应该添加到与生产代码相同的CL中，除非CL正在处理紧急情况。</p></li><li><p>审查者有必要确保测试是正确、合理、有用的。当代码真的有问题，测试是否会失败？如果被测试的程序发生改动时，测试是否会产生误报？每一个测试是否做出了简单而有用的断言？不同的测试方法之间是否适当分开？</p></li><li><p>请记住，测试代码也是需要维护的代码。不要因为测试不是主分支的一部分就接受测试中的复杂性。</p></li></ol><h3 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h3><ol><li><p>在CR中遇到任何冲突，首先应该是开发人员和审查者通过本文档的内容和代码规范尝试达成共识。</p></li><li><p>当达成共识比较困难时，审查者可以和作者进行面对面沟通。如果还不能解决问题，可以让更多的人(例如项目管理者)参与进来一起讨论解决冲突。</p></li></ol><h3 id="紧急状况"><a href="#紧急状况" class="headerlink" title="紧急状况"></a>紧急状况</h3><ol><li><p>紧急提交历史只能是一个小的更改：修复严重影响生产中用户的错误，处理紧迫的法律问题，关闭主要的安全漏洞等。</p></li><li><p>在紧急情况下，我们更关心整个代码审查过程的速度，仅在这种情况下，审查者应该更关心审查的速度和代码的正确性(它是否真的解决了紧急情况？)而不是其他任何事情。此外这种审核应该优先于所有其他代码审查。</p></li><li><p>但是，在紧急情况解决后，您应该再次查看紧急情况提交历史并对其进行更彻底的审查。</p></li></ol><h3 id="什么不是紧急情况？"><a href="#什么不是紧急情况？" class="headerlink" title="什么不是紧急情况？"></a>什么不是紧急情况？</h3><ol><li>以下情况不是紧急情况：<ul><li>想要在本周而不是下周发布(除非有一些实际的硬性发布期限，例如合同协议)。</li><li>开发人员已经在一个功能上工作了很长时间，他们很想审查通过。</li><li>今天是星期五，在开发人员开始周末之前审查通过会很棒。</li><li>……</li></ul></li></ol><h3 id="什么是硬期限？"><a href="#什么是硬期限？" class="headerlink" title="什么是硬期限？"></a>什么是硬期限？</h3><ol><li><p>硬期限指的是严格的截止日期，如果您错过它就 <strong>会发生灾难性事情</strong> 的截止日期。例如：</p><ul><li>为了履行合同义务，必须在某个日期之前完成。</li><li>如果未在特定日期之前发布，您的产品将在市场上完全失败。</li><li>一些硬件制造商每年只发货一次新硬件，如果您错过了向他们提交代码的截止日期，那可能是灾难性的。</li><li>……</li></ul></li><li><p>大多数截止日期都是软截止日期，而不是硬截止日期；它们代表了在某个时间完成某项功能的愿望，它们很重要，但不应该牺牲代码质量来达到目的。</p></li></ol><h3 id="CR太严格被抱怨怎么办？"><a href="#CR太严格被抱怨怎么办？" class="headerlink" title="CR太严格被抱怨怎么办？"></a>CR太严格被抱怨怎么办？</h3><ol><li><p>提高CR的速度通常会让这些抱怨逐渐消失。可能需要数个月，但最终开发人员会看到严格的CR所带来的价值，因为严格的CR会帮助他们产生更优秀的代码。</p></li><li><p>如果你遵循这些准则，并且如果CR非常严格的话，后面你会发现整个CR流程会越来越快。因为开发者会知道什么是质量好的代码，并且在开始就提交一个很棒的CL。但不要为提高想象中的速度，而对CR标准和代码质量做出妥协，毕竟从长远来看它实际上并不会让任何事情发生的更快。</p></li></ol><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><ol><li>可以转载，但是请注明来源。</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://google.github.io/eng-practices/review/reviewer/">Google的代码审查指南</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 代码人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序员 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码自测流程</title>
      <link href="/2022/01/20/%E4%BB%A3%E7%A0%81%E8%87%AA%E6%B5%8B%E6%B5%81%E7%A8%8B/"/>
      <url>/2022/01/20/%E4%BB%A3%E7%A0%81%E8%87%AA%E6%B5%8B%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<!-- > 由布多(budo)发布于 2023年10月26日 • 最后更新：2023年10月29日 --> <p>这篇文章是站在iOS客户端的角度写的，仅供参考。</p><h2 id="测试流程"><a href="#测试流程" class="headerlink" title="测试流程"></a>测试流程</h2><ol><li>根据需要测试的功能或页面编写一个简单的测试用例(<code>包含具体的测试步骤和一些容易忽略的点，把步骤写出来可以避免做重复工作，也避免漏掉需要测试的点</code>)。</li><li>切换至Release环境，尽量在真机上测试。</li><li>打开测试开关(<code>有些功能会在测试时单独打开，例如iOS客户端的FPS帧率显示控件</code>)。</li><li>开始测试。</li></ol><h2 id="用例参考"><a href="#用例参考" class="headerlink" title="用例参考"></a>用例参考</h2><h4 id="一-测试页面或功能的完整性"><a href="#一-测试页面或功能的完整性" class="headerlink" title="一. 测试页面或功能的完整性"></a>一. 测试页面或功能的完整性</h4><ol><li>测试所有的交互事件(包括但不限于点击、长按、拖拽等等)是否符合预期。</li><li>无网络进入页面然后恢复网络后是否会自动刷新。</li><li>模拟用户的正常操作。</li><li>模拟用户的非正常操作。<ol><li>例如有一个提现的输入框，你期待他输入一个数字，但他输入了一个字符串或复制粘贴了字符串是否能正确处理。</li></ol></li><li>测试与页面或功能相关的点，例如APP适配了暗黑模式，那么也要测试一下页面在暗黑模式下是否正常显示，以及切换与关闭后是否显示正常。</li><li>……</li></ol><h4 id="二-测试服务端数据"><a href="#二-测试服务端数据" class="headerlink" title="二. 测试服务端数据"></a>二. 测试服务端数据</h4><ol><li>测试当服务端数据返回为空对象或null时是否能正确处理。</li><li>测试当返回的对象类型不一致时会怎么样(例如约定返回数组实际返回了字符串)。</li><li>……</li></ol><h4 id="三-测试UI"><a href="#三-测试UI" class="headerlink" title="三. 测试UI"></a>三. 测试UI</h4><ol><li>运行到不同尺寸的机型上测试页面是否显示正常(iOS需要覆盖全部屏幕机型，包括4、4.7、5.4、5.5、5.8、6.1、6.5、6.7，安卓只需要覆盖常见的一些屏幕机型即可)。</li><li>运行到不同的系统上测试(例如APP最低适配iOS10，那么只要测试10到最新版本的大版本就行了)。</li><li>……</li></ol><h4 id="四-测试网络"><a href="#四-测试网络" class="headerlink" title="四. 测试网络"></a>四. 测试网络</h4><ol><li>测试弱网情况下进入页面或使用功能是否符合预期。</li><li>测试使用过程中发生弱网是否能正确处理(例如进入支付页面、输入支付密码前网络都正常，但是交易过程中却发生了弱网)。</li><li>测试当用户开启代理或VPN的时候是否符合预期。</li><li>……</li></ol><h4 id="五-测试极端情况"><a href="#五-测试极端情况" class="headerlink" title="五. 测试极端情况"></a>五. 测试极端情况</h4><ol><li>当返回数据非常多时是否能正确处理(例如一个分类列表，正常情况下只会有10几个分类，如果突然返回上百个甚至更多分类时，是否能正确处理)。</li><li>用户切换网络。</li><li>低电量自动关机。</li><li>来电话。</li><li>用户点击通知切换到其他APP。</li><li>……</li></ol><h4 id="六-收尾工作"><a href="#六-收尾工作" class="headerlink" title="六. 收尾工作"></a>六. 收尾工作</h4><ol><li>按照 <a href="https://juejin.cn/post/7018484631057989663"><strong>风格指南</strong></a> 和 <a href="https://juejin.cn/post/7055164422662127647/"><strong>开发规范</strong></a> 检查代码是否符合规范。</li><li>运行项目检查控制台是否有多余的警告信息(例如约束警告)。</li><li>检查是否存在内存泄漏。</li><li>删除测试数据。</li><li>切换到Debug环境。</li><li>关闭测试开关。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 代码人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序员 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Objc开发规范</title>
      <link href="/2022/01/20/Objc%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/"/>
      <url>/2022/01/20/Objc%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<!-- > 由布多(budo)发布于 2023年10月26日 • 最后更新：2023年10月29日 --> <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这篇文章是基于笔者个人经验以及一些开发规范总结而成，目的是提高公司内部项目的稳定性与效率。<br>文章的前半部分是一些通用开发规范，适用于所有编程语言甚至是生活中遇到的问题；<br>后半部分是关于OC的开发规范以及开发中容易犯的错误，如果不想看可以跳过。</p><h2 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h2><p>我们无法写出完全没有BUG的代码，但是我们可以尽量写出容易阅读和逻辑简单清楚的代码，容易阅读和逻辑简单清楚的代码从某种程度上会减少BUG以及BUG的修复难度。</p><h2 id="通用规范"><a href="#通用规范" class="headerlink" title="通用规范"></a>通用规范</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tips:</span><br><span class="line">虽然BUG无法完全避免，但是我们可以遵循一些规范和规则让BUG尽早暴露，或者让它便于排查。</span><br></pre></td></tr></table></figure><ul><li><p><strong>[必须]</strong> 开发完一个模块(<code>功能、页面等等</code>)时，自测一遍，确认没有问题后再开发下一个模块，如果一个模块很大，可以完成一个小功能时自测一遍，不要把所有问题都放到最后测试，更不要依赖测试人员，关于自测流程可以参考<a href="https://juejin.cn/post/7055161752681447460">自测流程规范</a>。</p></li><li><p><strong>[必须]</strong> 禁止实现未来可能需要的功能，如果这个功能现在不需要就不要实现它，等未来需要的时候再去实现它，因为那个时候你可以更清晰的看到那个功能完整的模样(<code>如果必须要实现它，必须要考虑所有可能发生的情况以及细节，并且加上注释说明</code>)。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tips:</span><br><span class="line">实现一个未来可能需要的功能在大部分情况下都是得不偿失的，有以下缺点：</span><br><span class="line">1. 未来可能不需要这个功能。</span><br><span class="line">2. 增加垃圾代码，当别人看见这段代码时不理解为什么要这么写。</span><br><span class="line">3. 增加维护成本和开发时间(即使某段代码不使用也是需要维护的)。</span><br><span class="line">4. 后期真正要用的时候可能会发现当初实现的时候考虑不全面，最后还是要重新写一遍。</span><br><span class="line">5. ……</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 不要尝试去推测并解决未来可能发生的问题，等问题出现的时候再去解决它，因为那个时候你可以更清晰的看见问题的真实样子。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tips:</span><br><span class="line">这个规则不是说要你发现问题了不去解决等到被别人发现提出后再解决；</span><br><span class="line">现实生活中有一些完美主义者想让自己写的代码非常完美没有任何问题，所以他们会尽</span><br><span class="line">量假设各种各样的情况，甚至很多极端情况，有时候会为了一个发生概率很小并且</span><br><span class="line">影响不是很重要的问题而大改特改，直到满意为止，这么做很可能会影响别人甚至导致项目延迟上线。</span><br><span class="line">在修改过程中如果改动的范围特别大还可能会引进新的问题，而且由于这个问题是未来</span><br><span class="line">可能会发生的问题，所以可能还会有你没考虑到的地方，最后既引进了新的问题还可能没解决问题。</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 对于服务端返回的值，永远不要假设它是正确的类型和值(<code>即使服务端的人保证</code>)，使用之前必须检查它的真实类型和值是否符合预期。</p></li><li><p><strong>[必须]</strong> 不要让代码脱离开发者的掌控。当我们开发一个功能时，总是希望让使用者调用更少的API或者自动调用，但是有些步骤让使用者主动调用会更好一些，这样使用者知道他干了什么，而不是出了问题时一头雾水，当你把某个步骤设置成自动调用时想一下这是否有必要？如果不是请让使用者主动调用它并在文档中加以说明。</p></li><li><p><strong>[必须]</strong> 所见即所得，例如页面上2个控件的间距是10，那么代码中的间距设置也应该是10，而不应该是一个控件很高，有很多的空白区域，然后用-xx(负间距)去填充。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">UILabel *label1 = [[UILabel alloc] init];</span><br><span class="line">label1.frame = CGRectMake(0, 0, 100, 30);</span><br><span class="line"></span><br><span class="line">UILabel *label2 = [[UILabel alloc] init];</span><br><span class="line">label2.frame = CGRectMake(0, 30 + 10, 100, 30);</span><br><span class="line">上述代码明显的告诉你 label2 的顶部和 label1 的底部间距为10。</span><br><span class="line"></span><br><span class="line">反例：</span><br><span class="line">UILabel *label1 = [[UILabel alloc] init];</span><br><span class="line">label1.frame = CGRectMake(0, 0, 100, 30);</span><br><span class="line"></span><br><span class="line">UILabel *label2 = [[UILabel alloc] init];</span><br><span class="line">label2.frame = CGRectMake(0, -20, 100, 90);</span><br><span class="line">假设文字实际展示需要 30 高度，上述代码和正例中的代码给用户的感觉是一样的，</span><br><span class="line">但是阅读性却非常差。</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 一般情况下禁止使用过时的方法或类，应该及时去了解和使用新方法或类。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tips:</span><br><span class="line">对于过时的方法或类，大都是因为其自身有缺陷或BUG，</span><br><span class="line">使用新方法前建议了解一下旧方法/类废弃的原因。</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 尽量不要使用runtime去交换方法，可以使用中间者模式或者其他方法代替，如果一定要这么做，那么请留下注释说明交换方法后做了什么，以及为什么要这么做？</p></li><li><p><strong>[必须]</strong> 尽量不要直接使用成员变量，而是使用属性替代它。</p></li><li><p><strong>[必须]</strong> 在dealloc方法内禁止将self传递出去，如果self被retain，到下个runloop周期再释放则会多次释放导致crash。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">反例：</span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">    [self unsafeMethod:self];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 对剪切板的读取操作必须放在子线程中进行，因为用户可能在Mac上复制大量数据然后通过接力同步到iPhone上。</p></li><li><p><strong>[必须]</strong> 当方法可能会提前return时，需要注意对象的释放问题，避免内存泄漏。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">反例：</span><br><span class="line">CFArrayRef arrayRef = (__bridge CFArrayRef)array;</span><br><span class="line"></span><br><span class="line">if (x == YES) return;</span><br><span class="line"> </span><br><span class="line">CFRelease(arrayRef);</span><br><span class="line"></span><br><span class="line">如果if条件成立那么arrayRef对象就会内存泄漏。</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 使用@try处理异常时，需要注意对象的释放问题，避免内存泄漏。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">反例：</span><br><span class="line">@try &#123;</span><br><span class="line">CFArrayRef arrayRef = (__bridge CFArrayRef)array;</span><br><span class="line">    </span><br><span class="line">do some thing……</span><br><span class="line"></span><br><span class="line">CFRelease(arrayRef);</span><br><span class="line">        </span><br><span class="line">&#125; @catch (NSException *exception) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">如果do some thing……出现异常的话那么arrayRef就会出现内存泄漏。</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 如果使用到的值和另一个值有所关联，在代码中体现出这种关联性，这能增加代码可读性，也能增加代码稳定性。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tips:</span><br><span class="line">例如有1个头像控件需要显示为圆形，我们经常会这样设置：</span><br><span class="line">1. 给头像控件设置圆角：layer.cornerRadius = 15.0;</span><br><span class="line">2. 给头像控件设置宽高：.frame = CGRectMake(0, 0, 30.0, 30.0);</span><br><span class="line">// 上述代码中的15.0 和 30.0 就没有任何关联性，如果它们之间相隔了很多代码，</span><br><span class="line">   修改宽高的时候可能会忘记修改cornerRadius。</span><br><span class="line">   </span><br><span class="line">正例：</span><br><span class="line">1. 给头像控件设置圆角：layer.cornerRadius = 15.0;</span><br><span class="line">2. 给头像控件设置宽高：.frame = CGRectMake(0, 0, layer.cornerRadius * 2.0, layer.cornerRadius * 2.0);</span><br><span class="line">// 这样后面阅读代码的人一眼就能明白宽高和 layer.cornerRadius 的关系，既增加了可读性，又增加了稳定性。</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 如果一个值需要特别多个变量计算出来，请把它们提取成一个变量并且加上注释说明这个变量是怎么组成的。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">// 屏幕宽度 - label左边距 - label右边距 - 开关按钮宽度 - 按钮右边距</span><br><span class="line">    CGFloat titleMaxWidth = kScreenWidth - labelLeftSpacing - labelRightSpacing - buttonWidth - buttonRightSpacing;</span><br><span class="line"></span><br><span class="line">// 这样写的好处在于以后如果需要修改某个控件的布局信息，只需要修改一处即可，降低了后续维护难度。</span><br></pre></td></tr></table></figure></li><li><p><strong>[建议]</strong> 声明常量尽量使用const类型，不要使用#define。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tips: </span><br><span class="line">宏定义声明常量的缺点：</span><br><span class="line">1. 宏定义只是简单的替换，缺少编译检查，运行期可能会出现溢出或数据错误等问题。</span><br><span class="line">2. 宏定义缺少类型，不方便编写文档用例。</span><br><span class="line">3. 宏定义可能会被替换。</span><br><span class="line">4. 宏定义无法编写符合规范的注释信息。</span><br><span class="line"></span><br><span class="line">反例：</span><br><span class="line">#define kTime @&quot;10&quot;</span><br><span class="line">    </span><br><span class="line">if (NO) &#123;</span><br><span class="line">#define kTime @&quot;20&quot;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">NSLog(@&quot;time = %@&quot;, kTime);</span><br><span class="line"></span><br><span class="line">即使if永远不会执行，但是编译器也会将kTime替换为@&quot;20&quot;</span><br></pre></td></tr></table></figure></li><li><p><strong>[建议]</strong> 工具类尽量在头文件的注释中写清楚该功能如何使用，以及需要注意的事项。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tips:</span><br><span class="line">1. 如果是一个UI工具，使用时是否需要提前设置frame，是否可以使用约束布局？</span><br><span class="line">2. 对于一些比较复杂的工具，最好在注释中给出一段示例代码。</span><br><span class="line">包括但不限于上述的注意事项，</span><br><span class="line">例如一个封装好的弹窗工具，应该说明如何弹出，是否需要提前设置frame或者约束</span><br><span class="line"></span><br><span class="line">以下是一个简单的示例伪代码:</span><br><span class="line">/**</span><br><span class="line">* @brief UIActivityIndicatorView的增强版，和UIActivityIndicatorView使用方式一致，但扩展了一些额外功能。</span><br><span class="line">* @discussion 1. 除了可以自定义颜色之外，还可以自定义指示器的详细大小(例如指示器宽度、高度、离心距离等)。</span><br><span class="line">* @discussion 2. 内部会自动计算控件所需要的最小宽高，可以不设置宽高约束或宽高Frame。</span><br><span class="line">* @discussion 3. 可以暂停/恢复指示器动画。</span><br><span class="line">* @code</span><br><span class="line">* LLActivityIndicatorView *activityIndicatorView = [LLActivityIndicatorView activityIndicatorWithStyle:LLActivityIndicatorViewStyleGrayMedium];</span><br><span class="line">* activityIndicatorView.backgroundColor = UIColor.redColor;</span><br><span class="line">* activityIndicatorView.frame = CGRectMake(0, 0, 50, 50);</span><br><span class="line">* activityIndicatorView.center = self.view.center;</span><br><span class="line">* [self.view addSubview:activityIndicatorView];</span><br><span class="line">* [activityIndicatorView startAnimating];</span><br><span class="line">* @encode</span><br><span class="line">*/</span><br><span class="line">@interface LLActivityIndicatorView : UIView</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 不要滥用懒加载，只在必要时刻使用它。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">只在以下三种情况下才使用懒加载：</span><br><span class="line">1. 对象的创建需要依赖其他对象</span><br><span class="line">2. 对象可能被使用，也可能不被使用</span><br><span class="line">3. 对象创建比较消耗性能</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 使用NSUserDefaults存储数据时禁止调用synchronize方法，因为系统会在合适的时机将数据保存到本地(即使程序闪退等极端情况)。</p></li><li><p><strong>[建议]</strong> 对于一些体积小并且不是特别重要的数据，不要频繁的进行写入操作，可以使用NSUserDefaults。它会在合适的时机将数据存储到本地，这避免了频繁的写入操作，而且在某些极端情况下它也能保证数据存储到本地(例如程序闪退等情况)。</p></li><li><p><strong>[必须]</strong> 添加到集合中的对象应该是不可变的，或者在加入之后其哈希值是不可变的。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">反例：</span><br><span class="line">NSMutableSet *sets = [NSMutableSet set];</span><br><span class="line">NSMutableString *string1 = [NSMutableString stringWithString:@&quot;1&quot;];</span><br><span class="line">[sets addObject:string1];</span><br><span class="line">[sets addObject:@&quot;12&quot;];</span><br><span class="line">    </span><br><span class="line">[string1 appendString:@&quot;2&quot;];</span><br><span class="line"></span><br><span class="line">当 [string1 appendString:@&quot;2&quot;] 执行完以后sets对象内会包含2个@&quot;12&quot;。</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 不可变对象请使用copy修饰，如果重写set方法，请注意调用copy方法。</p></li><li><p><strong>[必须]</strong> 请使用CGRectGet函数获取Frame的各种值，而不是通过frame.的方式获取。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tips:</span><br><span class="line">CGRect t_frame = CGRectMake(-10, -10, -10, -10);</span><br><span class="line">当一个view的frame设置成t_frame后，其坐标会隐式的转换为CGRectMake(-20, -20, 10, 10)，</span><br><span class="line">因为宽高不可能出现负值；</span><br><span class="line">这时通过t_frame.的方式获取的值都是错误的，而CGRectGet会自动帮您处理这些隐式转换。</span><br><span class="line"></span><br><span class="line">正例：</span><br><span class="line">CGRectGetWidth(frame)、CGRectGetMinX(frame)、CGRectGetMaxX(frame)</span><br><span class="line"></span><br><span class="line">反例：</span><br><span class="line">frame.size.width、frame.origin.x、frame.size.width + frame.origin.x</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 代码中单行字符数不要超过150个，超过请换行(空格除外)，可以在 Xcode -&gt; Preferences… -&gt; Text Editing -&gt; Page guide at column 中设置为150方便排查。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">- (void)setImageWithURL:(nullable NSURL *)imageURL</span><br><span class="line">            placeholder:(nullable UIImage *)placeholder</span><br><span class="line">                options:(YYWebImageOptions)options</span><br><span class="line">               progress:(nullable YYWebImageProgressBlock)progress</span><br><span class="line">               ransform:(nullable YYWebImageTransformBlock)transform</span><br><span class="line">             completion:(nullable YYWebImageCompletionBlock)completion;</span><br></pre></td></tr></table></figure></li><li><p><strong>[建议]</strong> 单个方法的行数建议不超过80行，注释、左右大括号、空行、回车等除外。</p></li><li><p><strong>[必须]</strong> 在多线程环境下谨慎使用可变集合，必要时候可以采用加锁或GCD的同步线程进行保护，或者在访问可变集合时先将其copy为不可变对象然后再对其访问。</p></li><li><p><strong>[必须]</strong> 属性和方法必须有 <strong>nullable</strong> 或 <strong>nonnull</strong> 限定符，由于OC是动态语言，所以即使使用 <code>nonnull</code> 声明对象不为空，使用前也必须判断是否为空。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">- (void)setName:(NSString * _Nonnull)name &#123;</span><br><span class="line">    if (name == nil) &#123;</span><br><span class="line">      ………</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 如果有使用到数组、字典等类型，尽量使用泛型声明其包含的类型，这样可以提高代码可读性。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">NSArray&lt;NSString *&gt; *array;</span><br><span class="line"></span><br><span class="line">反例：</span><br><span class="line">NSArray *array;</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 如果类中包含多个初始化方法，请使用 <code>NS_DESIGNATED_INITIALIZER</code> 和 <code>NS_UNAVAILABLE</code> 宏标记提高代码可读性。</p></li><li><p><strong>[必须]</strong> 避免使用无符号整数(除非匹配系统接口使用的类型)，在工程中全部使用一种类型可以提高代码安全与一致性，无符号整数在进行数学运算和倒数到零的时候会出现细微的错误。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">NSUInteger numberOfObjects = array.count;</span><br><span class="line">for (NSInteger counter = numberOfObjects - 1; counter &gt; 0; counter--)</span><br><span class="line"></span><br><span class="line">反例：</span><br><span class="line">for (NSUInteger counter = numberOfObjects - 1, counter &gt; 0; counter--)</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 在自动引用计数下，OC对象会自动初始化为nil，但是有些对象不会自动初始化为nil，例如CoreFoundation中的对象，所以在声明局部对象时需要手动初始化。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">NSObject *obj = nil;</span><br><span class="line"></span><br><span class="line">反例：</span><br><span class="line">NSObject *obj;</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 不要使用一个类去维护多个类的内容，例如使用一个常量类维护所有的常量，要按功能进行归类，分开维护。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tips: </span><br><span class="line">大而全的类，杂乱无章，使用查找功能才能定位到具体位置，不利于理解也不利于维护。</span><br><span class="line"></span><br><span class="line">正例：</span><br><span class="line">缓存相关常量类放在CacheConsts下，系统配置相关常量类放在SystemConfigConsts下。</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 如果超类的某个初始化方法不适用于子类，那么子类一定要重写超类的这个方法解决问题或抛出异常。</p></li><li><p><strong>[必须]</strong> 把一些稳定的、公共的变量或者方法抽取到父类中。子类尽量只维持父类所不具备的特性和功能。</p></li><li><p><strong>[必须]</strong> 禁止将布尔对象直接和 YES 或者 NO进行判断，例如 &#x3D;&#x3D; YES， !&#x3D; YES，&#x3D;&#x3D; NO，!&#x3D; NO。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tips:</span><br><span class="line">在32位机器上YES被定义为1，NO定义为0；</span><br><span class="line">而64位机器上YES被定义为非0，NO定义为0；</span><br><span class="line"></span><br><span class="line">BOOL result = 4;</span><br><span class="line"></span><br><span class="line">if (result == YES) &#123;</span><br><span class="line">    NSLog(@&quot;YES&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    NSLog(@&quot;NO&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">以上代码在64位机器会输出YES，而上32位机器上则会输出NO。因为在32位机器上 </span><br><span class="line">(result == YES) 会被解释为 (4 == (signed int) 1)，</span><br><span class="line">所以会输出NO，而在64位机器上会认为result不等于0所以输出YES。</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 删除代码时将内部用到的无用文件、无用类、无用函数等统一删除干净。</p></li><li><p><strong>[建议]</strong> 如果可以，尽量使用 #undef 限制宏的作用范围。</p></li><li><p><strong>[建议]</strong> 局部变量尽量定义在最靠近使用它的地方。</p></li><li><p><strong>[建议]</strong> 在写一些简单的类方法和宏方法时，尽量使用内联函数或全局函数代替它。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tips:</span><br><span class="line">函数不通过对象调用，所以不会走OC的消息转发流程，效率高于方法调用；</span><br><span class="line">而且函数会有返回值和参数类型以及参数检查，这些都是宏定义没有的。</span><br><span class="line"></span><br><span class="line">正例：</span><br><span class="line">UIKIT_STATIC_INLINE NSString * kNSStringFromInteger(NSInteger a) &#123;</span><br><span class="line">    return [NSString stringWithFormat:@&quot;%zd&quot;, a];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">反例：</span><br><span class="line">#define kNSStringFromInteger(a) [NSString stringWithFormat:@&quot;%zd&quot;, a]</span><br></pre></td></tr></table></figure></li><li><p><strong>[建议]</strong> 如果用到了很多协议，必要时可以把协议封装到一个单独的头文件中，这样做不仅可以减少编译时间，还能避免循环引用。</p></li><li><p><strong>[建议]</strong> 使用switch枚举时尽量将所有枚举类型都case出来而不要使用default，这样的话以后增加或删除枚举类型时如果switch没有处理的话编译器会有警告提醒。</p></li><li><p><strong>[建议]</strong> 尽量使用字面量语法创建对象，少用与之等价的方法。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tips:</span><br><span class="line">OC中的NSArray、NSString、NSDictionary、NSNumber都有与之对应的字面量语法: @[]、@&quot;&quot;、@&#123;&#125;、@()；</span><br><span class="line">使用它们有以下优点：</span><br><span class="line">1. 简单易读，提高代码的可读性和维护性。</span><br><span class="line">2. 使用字面量创建数组、字典时如果元素里在nil则会抛出异常，</span><br><span class="line">   而使用arrayWithObjects:方法创建则会丢失nil后的数据，</span><br><span class="line">   抛出异常能让你知道这里有问题及时修改防止问题在线上发生。</span><br><span class="line"></span><br><span class="line">缺点：</span><br><span class="line">1. 使用字面量创建的对象默认是不可变的，如果要创建可变对象需要进行mutableCopy操作。</span><br><span class="line">2. 不支持子类，如果你创建了一个NSString的子类，@&quot;&quot;并不会返回你想要的子类对象。</span><br></pre></td></tr></table></figure></li><li><p><strong>[建议]</strong> UI控件尽量使用weak修饰而不是strong修饰，这样对梳理对象引用会更清晰明了。</p></li><li><p><strong>[建议]</strong> 尽量不要使用+load方法，如果必须要使用那么不要在方法内实现复杂逻辑或堵塞线程。</p></li><li><p><strong>[建议]</strong> 尽量减少继承层级，类的继承建议不要超过3层，必要时刻可以考虑用分类、协议来代替继承。</p></li></ul><h2 id="头文件规范"><a href="#头文件规范" class="headerlink" title="头文件规范"></a>头文件规范</h2><ul><li><p><strong>[必须]</strong> 头文件中尽量不要直接引用其他头文件，而是使用@class向前声明，每次引入其他头文件时先问问自己是否必须要这样做。</p></li><li><p><strong>[建议]</strong> 头文件中暴露的方法和属性尽可能少，例如外部只需要覆值操作，那就不要提供getter方法或者属性。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">@interface BookView : NSObject</span><br><span class="line"></span><br><span class="line">- (void)setBookName:(NSString *)bookName;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">反例：</span><br><span class="line">@interface BookView : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong) NSString *bookName;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></li><li><p><strong>[建议]</strong> 头文件中的属性尽量声明为只读，可以在实现文件中再将属性声明为可读可写。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">@interface WXYZModel : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, readonly) NSString *name;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface WXYZModel ()</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong) NSString *name;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation WXYZModel</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></li></ul><h2 id="Block开发规范"><a href="#Block开发规范" class="headerlink" title="Block开发规范"></a>Block开发规范</h2><ul><li><p><strong>[必须]</strong> 在Block内部使用上下文的对象时要注意相互引用的问题(<code>不一定要在 block 内使用 self 才会相互引用</code>)。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tips: </span><br><span class="line">1. 不一定在Block内使用self才会相互引用，如下情况也会造成循环引用:</span><br><span class="line">- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123;</span><br><span class="line">    WXYZ_TitleTableViewCell *cell = ………</span><br><span class="line">    </span><br><span class="line">    cell.refreshTableViewBlock = ^&#123;</span><br><span class="line">        [tableView reloadData];</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    return cell;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2. Block内部是否要使用weak需要看Block本身和weak的这个对象是否存在直接或间接的相互引用，</span><br><span class="line">   若无相互引用则不需要使用weak。</span><br><span class="line"></span><br><span class="line">3. 如果Block内部使用了strong修饰了外部的weak变量，那么当使用strong指向成员变量时需要进行判空，否则会崩溃，参考以下代码:</span><br><span class="line">__weak typeof(self) weakSelf = self;</span><br><span class="line">    cell.refreshTableViewBlock = ^&#123;</span><br><span class="line">        __strong typeof(weakSelf) strongSelf = weakSelf;</span><br><span class="line">        if (strongSelf != nil) &#123;</span><br><span class="line">            strongSelf-&gt;_name = @&quot;name&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">如果把(strongSelf != nil)的判断去掉那么可能会崩溃。</span><br></pre></td></tr></table></figure></li></ul><h2 id="通知开发规范"><a href="#通知开发规范" class="headerlink" title="通知开发规范"></a>通知开发规范</h2><ul><li><p><strong>[必须]</strong> 在发送通知时，请使用<code>userInfo</code>对象进行传值，而不是<code>object</code>。</p></li><li><p><strong>[必须]</strong> 避免重复注册通知，这会导致重复执行通知方法。</p></li><li><p><strong>[必须]</strong> 在使用通知的<code>object</code>参数时，需要确保接收方和发送方的object对象类型是一致的。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">反例：</span><br><span class="line">[NSNotificationCenter.defaultCenter addObserver:self selector:@selector(testFunction) name:@&quot;testNotificationName&quot; object:model.bookID];</span><br><span class="line">[NSNotificationCenter.defaultCenter postNotificationName:@&quot;testNotificationName&quot; object:@&quot;123&quot;];</span><br><span class="line"></span><br><span class="line">假设 model.bookID 的值就是字符串123，也可能无法收到通知，</span><br><span class="line">因为NSString有__NSCFConstantString， __NSCFString， NSTaggedPointerString等多个子类对象，</span><br><span class="line">如果 model.bookID 的真实对象类型是 NSTaggedPointerString 的话就会收不到通知。</span><br></pre></td></tr></table></figure></li><li><p><strong>[建议]</strong> 在工程里能不用通知尽量不用通知，通知虽然灵活强大，但是如果滥用会导致工程质量下降并且增加维护难度。</p></li></ul><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><ol><li>可以转载，但是请注明来源。</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://book.douban.com/subject/25829244/">Effective Objective-C 2.0  编写高质量iOS与OS X代码的52个有效方法</a></li><li><a href="https://google.github.io/styleguide/objcguide.html">Google的Objective-C风格指南</a></li><li><a href="https://google.github.io/eng-practices/review/reviewer/">Google的代码审查指南</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 代码人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Objc </tag>
            
            <tag> 代码规范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git命令手册</title>
      <link href="/2021/08/11/Git%E5%91%BD%E4%BB%A4%E6%89%8B%E5%86%8C/"/>
      <url>/2021/08/11/Git%E5%91%BD%E4%BB%A4%E6%89%8B%E5%86%8C/</url>
      
        <content type="html"><![CDATA[<!-- > 由布多(budo)发布于 2023年10月26日 • 最后更新：2023年10月29日 --> <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><hr><p>&nbsp;&nbsp;&nbsp;&nbsp;该手册(以下简称它)不是Git入门教程，如果您想入门Git推荐<a href="https://www.liaoxuefeng.com/wiki/896043488029600">廖雪峰的Git教程</a></p><p>&nbsp;&nbsp;&nbsp;&nbsp;这只是一篇个人学习Git时顺带记录的命令手册以及对Git的一些理解心得，如有不正确的地方欢迎大家留言指正。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;它包含了Git几乎所有的高级命令和部分底层命令，每个命令都有详细的解释和示例告诉您如何使用，以及使用时需要注意的地方；内容按模块划分，比如和<code>add</code>相关的命令就都会集中在一个模块，大家可以选择自己感兴趣的模块自由阅读，由于某些命令的选项非常多但是并不常用，所以该手册可能没有记录，如果想查看某个命令的所有选项请查阅<a href="https://git-scm.com/docs">Git命令参考</a>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;有些比较简单的命令这里可能没有记录，文章中的()表示的是全称，例如{u(upstream)}，表示upstream是u的全称，实际使用的时候用@{u}或者@{upstream}都可以。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;Git本身是一个内容寻址文件系统，Git的核心部分是一个简单的键值对数据库，你可以向Git仓库中插入任意类型的内容，它会返回一个唯一的键，通过该键可以在任意时刻再次取回该内容。</p><blockquote><p>Tips： </p><ol><li><p>Git里一些同名的选项在相似的地方也可以使用。例如<code>--abort</code>选项，和<code>git merge --abort</code>搭配可以撤销合并操作，和<code>git rebase --abort</code>搭配可以撤销rebase操作。</p></li><li><p>Git里的大部分选项都是可以搭配一起使用的，例如<code>git log --author=&#39;internetwei&#39; --after=&quot;2020-01-01&quot; --before=&quot;2020-06-01&quot; --no-merges -- WXReader/Book/BookRack/BookReader</code><br>这行命令搭配了多达5个选项(指定作者，指定开始时间，指定结束时间，非合并提交，指定路径)， 它的意思是：打印<code>internetwei</code>作者在2020年1月1号到2020年6月1号之间对<code>WXReader/Book/BookRack/BookReader</code>这个文件夹(包括文件夹下所有文件)进行修改的所有提交记录但不包括合并提交。</p></li><li><p>Git里需要使用哈希值的地方不需要复制整个哈希字符串，通常只需要复制前6~8个字符就够了，如果项目比较大可以扩大到前8~10个，即使是像<code>Linux</code>这样的项目也只需要前10~12个字符即可保证唯一性。</p></li></ol></blockquote><h3 id="Git的特点"><a href="#Git的特点" class="headerlink" title="Git的特点"></a>Git的特点</h3><hr><ol><li><p>Git和SVN(其他版本控制工具)对待文件的区别？</p><blockquote><p>Git保存的不是文件的差异或变化，而是文件快照(快照可以简单的理解为这个文件的副本)，如果一个文件在提交的时候没有任何变化那么Git只会保留一个链接指向之前存储的内容；而SVN保存的是这个文件提交时的差异变化。 </p></blockquote></li><li><p>Git如何保证完整性?</p><blockquote><p>Git所有的数据在存储前都会计算校验和，计算校验和的机制叫做SHA－1散列(hash、哈希)，这是一个由40个16进制字符(0<del>9,a</del>f)组成的字符串，基于文件的内容和目录结构计算出来的(由于相同的文件计算出来的哈希值是一样的，所以当你存储一个文件到Git仓库时，如果Git发现已经有了就只会创建一个链接指向之前存储的那个对象)，计算出来的哈希值就像这样：<code>a6b6695a3594cc79b3c3fa9ef5772df036ec8d8e</code>，校验和的前两个字符用于命名子目录，剩下的38个字符则用作文件名，Git数据库中保存的信息都是以哈希值来索引。</p></blockquote></li><li><p>Git暂存和提交时分别做了什么？</p><blockquote><p>当你进行暂存操作时，Git会对每个文件计算校验和，然后将这些校验和加入到暂存区等待提交。</p><p>当你进行提交操作时，Git会计算每个子目录的校验和以及对所有的文件创建快照并保存快照的索引，然后Git会在仓库中把这些校验和保存为一个树对象，然后Git会创建一个提交对象，它包含一个指向最上层树对象的指针和一个指向父对象的指针(如果是合并提交会有2个父对象，如图1)，还有作者的名称、邮箱地址、提交说明。</p></blockquote><p> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/50c7be27cd9a4bca9c4a75c2f7df54ea~tplv-k3u1fbpfcp-zoom-1.image"> 图1</p></li><li><p>Git暂存区的作用</p><blockquote><p>大部分的版本管理(SVN)都没有暂存区的概念，Git的add命令和其他类似工具的add命令也不太一样，其他工具的add命令是将文件加入到版本管理，而Git的add命令有3种作用：1. 将未跟踪的文件加入到版本管理；2. 将已修改的文件内容加入到暂存区；3. 将冲突文件标记为冲突已解决状态。由于Git暂存区的存在，你可以在完成提交前审查你的提交内容，还可以精确的控制每一行的提交内容。例如一个文件有20行是修改BUG，另外有100行是添加新功能，现在我只想提交这个文件的修改BUG的那20行代码，那么只需要把这20行代码加入到暂存区就行了。 </p></blockquote></li><li><p>Merge的逻辑</p><blockquote><p>如果Git发现可以快进合并的话那么Git会直接把当前分支指向合并分支的最新提交(快进合并有一个缺点就是当你删除合并分支后会无法知道这个分支以前是从哪个分支合并过来的，如果想禁用快进合并可以使用<code>--no-ff</code>选项，这样Git会创建一个合并提交)，如果不可以快进合并的话Git会使用这两个分支的末端提交对象以及这两个分支的首个公共祖先提交，做一个简单的三方合并。</p></blockquote></li><li><p>GPG签名</p><blockquote><p>GPG可以签名你的提交或标签，它能够有效的提高Git仓库的安全性，因为它可以证明这个提交或标签是通过你信任的电脑提交的而不是某个冒用你名号的黑客，这相当于赋予了提交对象一种不可更改性，即使黑客通过某种办法拿到了Git仓库的读写权，他也没有办法添加或使用–force修改任何带有你GPG签名的提交或标签。</p><p>由于Git的作者名称和邮箱地址是可以随意填写的，如果有人将他的作者名称和邮箱地址改成和你的一样，然后通过某种方式将代码推送到了你的仓库中……这可能会导致你或其他人遭受损失，使用GPG签名可以尽量避免这种情况的发生。使用GPG签名过的提交在Github上显示如图2，你可以点击标签查看具体的签名信息。<br> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e21c63b735445c6b17e2d4790a291a1~tplv-k3u1fbpfcp-zoom-1.image"> 图2 </p></blockquote></li><li><p>HEAD是什么？</p><blockquote><p>HEAD本质就是一个指针，也可以叫做符号指针，因为通常情况下它指向一个分支(符号)，通过它可以获取你仓库当前的状态，可以使用<code>git symbolic-ref HEAD</code>查看当前HEAD的状态。</p><p>当HEAD指向一个具体的提交对象而不是分支引用时，Git会提示您处于“游离状态”，“游离状态”表示你当前不处于任何分支，所以你不能进行提交，只能查看提交快照的内容，也可以进行修改运行，如果你想要进行提交则需要先创建一个分支，“游离状态”通常用于调试或回滚某次提交。 </p></blockquote></li><li><p>HEAD^和HEAD~的区别？</p><blockquote><p>当后面不跟数字的时候^和~表示的意思相同，都表示第1个父提交对象；如果后面跟上数字就有差别了，^后面只能跟数字1或者数字2，^1表示当前对象的第1父提交，^2表示当前对象的第2父提交，只有合并提交对象才有第2父提交，第1父提交就是合并时接受合并的分支，第2父提交就是合并时被合并的那个分支；~后面理论上可以跟任意大于0的数字，~1表示当前提交对象的第1个父提交对象，~2表示当前提交对象的第2个父提交对象，以此类推，~2和~~表达同一个意思，不过当你想表示第100个父提交时，显然用~100比写100个~更现实，~和^可以组合使用，例如<code>git show HEAD~2^2</code>这行命令表示查看当前提交的第2个父提交的第2父提交内容。 </p></blockquote></li><li><p>Git中危险的命令</p><blockquote><p>在Git中任何已提交的内容几乎都是可以恢复的(那些被覆盖的提交也可以恢复)，但是未提交的内容丢失后可能再也找不回了，任何可能会导致工作区内容丢失的命令都是危险的命令，在Git中危险的命令总共可以分为3类:</p><ol><li>所有带<code>-f</code>选项的命令，<code>-f</code>的全称是<code>--force</code>，它表示强制的意思，例如<code>git push -f</code>表示强行将本地仓库推送到远程仓库，<code>git switch -f dev</code>表示强行切换到dev分支，总之使用<code>-f</code>选项时请小心。</li><li><code>git reset</code>命令总共有3个选项，<code>--soft</code>、<code>--mixed</code>、<code>--hard</code>，其中只有<code>--hard</code>选项是危险的命令，其他两个都是安全的，当你使用<code>--hard</code>选项时Git会使用仓库中指定的快照内容覆盖工作区。</li><li><code>git checkout</code>命令的本质是操纵HEAD指针，它的后面可以是分支名表示切换分支，也可以是文件路径，如果后面是文件路径，那么它就是一个危险的命令，Git会使用仓库中指定的快照内容覆盖工作区的指定文件(建议使用switch命令来切换分支，防止误操作导致丢失文件内容)。</li></ol></blockquote></li><li><p>checkout和reset的区别</p><blockquote><p>很多人容易把<code>checkout</code>和<code>reset</code>弄混，因为它们都可以用来回滚历史提交，虽然最终效果是一样的，但是实现过程确不一样；简单的说checkout命令会直接修改HEAD指针的指向，而reset命令修改的是HEAD指针指向的对象。</p><p>假设master分支有一个提交对象(ab4adf)，你想回滚到这次提交，Git提供了2种方式：<code>git checkout ab4adf</code>和<code>git reset --hard ab4adf</code>都可以达到你的目的，但它们的实现机制略微不一样；<code>git checkout ab4adf</code>会把HEAD指针直接指向ab4adf这个提交对象，然后再使用ab4adf这个提交对象的快照内容覆盖工作区的内容来达到目的(如果你细心观察的话会发现Git会提示你当前进入了HEAD游离状态)，如图3所示；<code>git reset --hard ab4adf</code>的实现就稍微复杂一些，它会操纵HEAD指针指向的对象(这里是master分支)指向ab4adf这次提交，然后再使用ab4adf这次提交中的快照内容覆盖暂存区和工作区的内容，如图4所示。<br><img src="https://gitee.com/internetWei/images/raw/master/uPic/%E6%88%AA%E5%B1%8F2021-08-03%2015.49.02.png"> 图3<br><img src="https://gitee.com/internetWei/images/raw/master/uPic/%E6%88%AA%E5%B1%8F2021-08-03%2015.49.49.png"> 图4</p></blockquote></li><li><p>Git协议的区别</p><blockquote><p>HTTP协议</p><blockquote><p>HTTP协议有2个版本，一种是哑协议(只能通过GET方式读取仓库内容)，另一种是智能协议，哑协议由于自身问题已经基本退出舞台了；相比SSH协议，HTTP协议可以使用用户名、密码授权是一个优势，就算不知道用户名和密码也可以获取项目，这很适合开源项目的推广，另一个优势就是HTTPS协议被广泛使用，一般的企业防火墙都会允许这些端口的数据通过；唯一的缺点就是在一些服务器上，架设HTTPS协议的服务端稍微棘手一些</p><blockquote><p>在使用HTTPS协议时，可能要重复输入用户名和密码，这时可以执行<code>git config --global credential.helper cache</code>命令来将用户名和密码临时缓存到内存中，可以使用<code>--timeout &lt;seconds&gt;</code>选项控制保留时长，默认是900秒(15分钟)</p></blockquote></blockquote></blockquote><blockquote><p>SSH协议</p><blockquote><p>架设SSH协议相对简单，SSH守护进程很常见，多数管理员都会使用，多数操作系统都包含它及相关的管理工具，相对于HTTPS协议它不用输入用户名和密码也更加方便；它的缺点是不支持匿名访问Git仓库，即使只是读取数据，使用者也必须通过SSH访问你的主机，所以SSH不利于开源项目</p></blockquote></blockquote><blockquote><p>Git协议</p><blockquote><p>是所有协议里传输速度最快的，因为没有加密和授权的开销；它的缺点是由于没有加密和授权，要么谁都可以克隆这个仓库，要么谁也不能，它也是最难架设的协议，还要求防火墙开放9418端口，但是企业防火墙一般都不会开放这个非标准端口。Git协议一般和其他协议(例如HTTPS)搭配使用，使用Git协议进行拉取，使用HTTPS协议进行推送。</p></blockquote></blockquote><blockquote><p>Local协议</p><blockquote><p>一般不会用到，所有没有去了解这方面的知识，有兴趣的可以自行搜索</p></blockquote></blockquote></li></ol><h4 id="Git-常用命令"><a href="#Git-常用命令" class="headerlink" title="Git 常用命令"></a>Git 常用命令</h4><ul><li><p><code>git help &lt;verb&gt;</code> 获取指定Git命令的帮助文档</p><blockquote><p>示例：</p><p><code>git help add</code> 获取add命令的帮助文档</p><p><code>-a</code> 列出所有的Git命令</p><p><code>-c(--config)</code> 列出所有可用的配置变量</p><p><code>git add -h</code> 简易版的帮助文档</p><blockquote><p>等价命令：</p><p>git &lt;verb&gt; –help</p><p>man git-&lt;verb&gt;  </p></blockquote></blockquote></li><li><p><code>git rm &lt;path&gt;</code> 删除指定文件</p><blockquote><p><code>--cached(--staged)</code> 从暂存区删除指定文件</p><blockquote><p>如果不小心把要忽略的文件添加到了Git仓库中，后续即使在忽略文件中声明也还是会在每次提交时提示你该文件未暂存；这时可以使用该命令从暂存区删除指定文件，该操作不会影响工作区。</p></blockquote><p><code>-n(--try-run)</code> 列出需要删除的文件  </p></blockquote></li><li><p><code>git describe &lt;commit&gt;</code> 根据指定提交对象生成一个字符串构建号。它由提交对象最近的标签名、自该标签之后的提交数目和你所描述的提交的部分哈希值构成(可以为提交附上一个可读的名称)。</p></li><li><p><code>git reflog</code> 显示所有的引用日志</p><blockquote><p>reflog的本质只是记录HEAD指针发生变化的记录，它只存在于本地仓库，一般情况下Git只会保留最近几个月(默认是90天)的记录  </p></blockquote></li><li><p><code>git reflog --date=local --all | grep &lt;分支名&gt;</code> 获取指定分支的HEAD变更记录</p><blockquote><p>可以用来查看某个分支是基于哪个分支创建的，由于reflog所以只能在创建分支的那台电脑上才能生效并且时间太长也会失效。  </p></blockquote></li><li><p><code>git clean</code> 移除那些没有被Git跟踪的文件，该命令需要搭配以下选项执行</p><blockquote><p><code>-d</code> 递归删除子目录下的文件&#x2F;文件夹</p><p><code>-f</code>如果<code>clean.requireForce</code>没有被设置为false，则必须要使用<code>-f</code>告诉Git需要删除那些文件</p><p><code>-n(--dry-run)</code> 只显示那些会被移除的文件</p><p><code>-x</code> 默认情况下不会删除被忽略的文件，-x表示将移除那些被忽略的文件</p><p><code>-X</code> 仅删除被忽略的未跟踪文件  </p></blockquote></li><li><p><code>git gc</code> 手动对Git仓库进行打包优化</p><blockquote><p><code>--aggressive</code> 加上此选项Git将会花费更多时间优化仓库</p></blockquote></li><li><p><code>git fsck</code> 验证数据库中对象的有效性</p><blockquote><p><code>--unreachable</code> 打印那些存在但无法从任何节点访问的对象  </p></blockquote></li><li><p><code>git restore</code> 恢复工作区的文件</p><blockquote><p><code>--staged &lt;path&gt;</code> 将指定文件从暂存区移除</p><p><code>-s(--source) &lt;tree_id&gt; &lt;path&gt;</code> 使用指定树中的文件恢复工作区的指定文件</p></blockquote></li><li><p><code>git clone -d &lt;分支名&gt; &lt;path&gt; --depth=&lt;number&gt;</code> 克隆指定仓库下指定分支的number条提交历史</p><blockquote><p>示例：</p><p><code>git clone -b master &lt;path&gt; --depth=1</code> 只克隆远程仓库的master分支的最近一条提交</p></blockquote></li></ul><h4 id="Git-Config"><a href="#Git-Config" class="headerlink" title="Git Config"></a>Git Config</h4><ul><li><p><code>git config --list</code> 查看Git配置信息，配置信息可能会重复，如果存在重复Git会以最后一个值为准。</p><blockquote><p><code>--show-origin</code> 显示该配置的来源(路径)</p></blockquote></li><li><p><code>git config &lt;范围&gt; &lt;选项&gt; &lt;值&gt;</code> 在指定范围内设置指定配置信息。</p><blockquote><p>示例：</p><p><code>git config --global user.name &#39;author&#39;</code> 在全局范围内设置提交者的名称。<br>Git Config总共有3个范围，分别是system、global、local(默认值)，权重依次递增，system的影响范围是最大的，针对当前电脑下的所有Git仓库都生效；global针对当前用户下的所有Git仓库生效；local只对当前Git仓库生效。  </p></blockquote></li><li><p><code>git config --global merge.conflictstyle diff3</code> 修改合并冲突样式为diff3，这种样式下会额外显示base的内容，如图5。</p><p>  <img src="https://gitee.com/internetWei/images/raw/master/uPic/%E6%88%AA%E5%B1%8F2021-08-10%2010.03.08.png"> 图5</p></li><li><p><code>git config --global help.autocorrect 50</code> 设置该选项后，当Git匹配了相似的命令时会在倒计时结束后自动执行该命令</p></li><li><p><code>git config --global core.autocrlf true</code> 启用该功能的话当你提交时Git会自动把回车和换行转换成一个换行符，而在检出代码时把一个换行符转换成回车和换行。</p><blockquote><p>在Windows的某些编辑器中，换行符是由回车符和换行符2个命令组成的，而在macOS和Linux系统中换行符只有一个符号。如果同一个项目在Windows和其他平台上开发，可能会遇到空格冲突。</p><p><code>input</code> 设置为input告诉Git在提交时把回车和换行转换成换行，检出时不转换</p></blockquote></li><li><p><code>core.whitespace</code> 空格处理方案，Git提供了6种处理多余空白字符的主要选项，3项默认开启，3项默认关闭</p><blockquote><p>默认开启：blank-at-eol(查找行尾的空格)，blank-at-eof(盯住文件底部的空行)，space-before-tab(警惕行头tab前面的空格)</p><p>默认关闭：indent-with-non-tab(揪出以空格而非tab开头的行，你可以用tabwidth选项控制它)，tab-in-indent(监视在行头表示缩进的tab)，cr-at-eol(告诉Git忽略行尾的回车)</p></blockquote></li></ul><p>如果想关闭某个选项，可以在输入设置选项时不指定它或在它前面加个 －</p><ul><li><p><code>git config &lt;范围&gt; alias.&lt;别名&gt; &#39;&lt;全名&gt;&#39;</code> 在指定范围内设置一个Git别名。</p><blockquote><p>示例：</p><p><code>git config --global alias.st &#39;status&#39;</code> 在全局范围内给status设置一个别名st。</p><p>别名通常用来简化命令，如果想给非Git命令起别名，例如gitk，可以这样设置<code>git config --global alias.gitk &#39;!gitk&#39;</code>，当你调用”git gitk”时会执行”gitk”命令。</p><blockquote><p>一些常用的别名：</p><p><code>git config --global alias.co checkout</code></p><p><code>git config --global alias.br branch</code></p><p><code>git config --global alias.ci commit</code></p><p><code>git config --global alias.st status</code></p><p><code>git config --global alias.s &#39;status -s&#39;</code></p><p><code>git config --global alias.last &#39;log -1&#39;</code>  </p></blockquote></blockquote></li><li><p><code>git config &lt;范围&gt; --unset alias.&lt;name&gt;</code> 删除指定别名</p></li></ul><h4 id="Git-Diff"><a href="#Git-Diff" class="headerlink" title="Git Diff"></a>Git Diff</h4><ul><li><p><code>git diff</code> 显示工作区和暂存区之间的差异</p><blockquote><p><code>--cached(--staged)</code> 显示暂存区和最新提交之前的差异</p><p><code>--check</code> 打印所有可能的空格错误</p><p><code>--ours</code> 冲突时查看合并引入了什么</p><p><code>--theirs -b</code> 冲突时查看合并的结果与另一边有什么不同，-b表示去除空格</p><p><code>--base</code> 冲突时查看文件在两边是如何改动的</p></blockquote></li></ul><h4 id="Git-Log"><a href="#Git-Log" class="headerlink" title="Git Log"></a>Git Log</h4><ul><li><p><code>git log</code> 显示当前分支下的提交历史</p><blockquote><p><code>-n</code> 显示指定数量的提交记录，例如<code>git log -2</code>显示最近2条提交记录</p><p><code>--show-signature</code> 显示GPG签名信息</p><p><code>--stat</code> 显示提交时的简略信息</p><p><code>--abbrev-commit</code> 显示简短的哈希值</p><p><code>--relative-date</code> 显示一个相对时间(例如 9 hours ago)</p><p><code>--graph</code> 在日志旁以ASCII图形显示分支和合并历史</p><p><code>--oneline</code> –pretty&#x3D;oneline和–abbrev-commit的缩写</p><p><code>--pretty=</code>  使用其他格式显示提交历史</p><blockquote><p><code>oneline</code> 将每条提交放在一行显示</p><p><code>short</code> 不显示提交时间</p><p><code>full</code> 不显示提交时间但额外显示提交者信息</p><p><code>fuller</code> 显示提交者信息以及提交时间</p><p><code>format</code> 自定义显示风格(自定义风格可以不受Git版本影响)</p><blockquote><p>示例：</p><p><code>git log --pretty=format:&quot;%Cred%h%Creset - %C(yellow)%an%Creset, %C(green)%ar%Creset : %s&quot;</code> 一行显示简写的提交哈希值 - 作者名称, 提交相对时间 : 提交说明。</p><p>format可接受的选项如下：</p><p><code>%H</code> 提交的完整哈希值</p><p><code>%h</code> 提交的简写哈希值</p><p><code>%T</code> 树的完整哈希值</p><p><code>%t</code> 树的简写哈希值</p><p><code>%P</code> 父提交的完整哈希值</p><p><code>%p</code> 父提交的简写哈希值</p><p><code>%an</code> 作者的名称</p><p><code>%ae</code> 作者的电子邮件地址</p><p><code>%ad</code> 作者的修订日期</p><p><code>%ar</code> 作者的修订日期，按多久以前的方式显示，例如20 hours ago</p><p><code>%cn</code> 提交者的名称</p><p><code>%ce</code> 提交者的电子邮件地址</p><p><code>%cd</code> 提交日期</p><p><code>%cr</code> 提交日期，按多久以前的方式显示</p><p><code>%s</code> 提交说明</p><p>Git支持的颜色选项：</p><p>normal、black、red、green、yellow、blue、magenta、cyan、white</p><p>Git支持的字体属性</p><p>bold、dim、ul、blink、reverse</p></blockquote></blockquote><p><code>--author</code> 显示和指定作者的提交记录</p><p><code>--committer</code> 显示和指定提交者的提交记录</p><p><code>--grep</code> 显示提交说明中包含指定字符串的提交记录</p><p><code>-S</code> 显示对指定字符串进行了修改的提交记录(常用来查找某个函数的修改提交记录)</p><p><code>-G &lt;正则表达式&gt;</code> 使用正则查找相关的提交记录</p><p><code>-- &lt;path&gt;</code> 显示指定路径下的修改记录(常用来和其他选项搭配查找某个文件下某个函数的修改提交记录，一般写在最后)</p><p><code>-L</code> 显示指定文件中指定函数的相关修改提交记录</p><blockquote><p>示例：</p><p><code>git log -L :firstApplication:WXReader/AppDelegate.m</code> 显示AppDelegate.m文件下与firstApplication相关的修改提交</p></blockquote><p><code>--no-merges</code> 不显示合并提交</p><p><code>--after(--since)</code> 显示指定时间之后的提交记录</p><p><code>--before(--until)</code> 显示指定时间之前的提交记录</p><blockquote><p><code>--after</code>和<code>--before</code>可以搭配指定的时间值，例如”2008-08-08”，也可以是”2 years 1 day 3 minutes ago”、”2.weeaks”这样的相对日期</p><p>示例：</p><p><code>git log --author=&#39;internetwei&#39; --after=&quot;2020-01-01&quot; --before=&quot;2020-06-01&quot; --no-merges -- WXReader/Book/BookRack/BookReader</code> 显示作者internetwei在2020年1月1号到2020年6月1号之间对<code>WXReader/Book/BookRack/BookReader</code>这个文件夹(包括文件夹下所有的文件)有关的所有修改提交但不包括合并提交</p></blockquote><p><code>&lt;分支1&gt;..&lt;分支2&gt;</code> 显示分支2有但分支1没有的提交记录(常用来检查分支哪些提交未推送)</p><blockquote><p>和..语法等价的命令：</p><p><code>git log ^&lt;分支1&gt; &lt;分支2&gt;</code></p><p><code>git log &lt;分支2&gt; --not &lt;分支1&gt;</code></p><p>上面两种命令是..语法的扩展，除了查询2个引用，还支持查询超过2个引用，例如<code>git log refA refB ^refC</code>表示显示所有被<code>refA</code>或<code>refB</code>包含但不被<code>refC</code>包含的提交记录</p></blockquote><p><code>&lt;分支1&gt;...&lt;分支2&gt;</code> 显示分支1和分支2不共有的提交</p><blockquote><p><code>--left-right</code> 和…等类似语法搭配使用，可以用&lt;、&gt;表示左右分支  </p></blockquote></blockquote></li><li><p><code>git shortlog</code> 显示当前分支的修改日志文档</p><blockquote><p>示例：</p><p><code>git shortlog --no-merges master --not v1.0</code> 显示master分支从v1.0标签后的所有非合并提交提交日志</p></blockquote></li></ul><h4 id="Git-Rebase"><a href="#Git-Rebase" class="headerlink" title="Git Rebase"></a>Git Rebase</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Merge和Rebase的区别：</span><br><span class="line"></span><br><span class="line">在Git中用来整合不同分支的修改有两种办法，一种是merge，另一种是rebase，这两种方案最终的结果没有任何区别，只不过提交历史不一样罢了，Rebase是将一系列的提交按照原有次序依次应用到另一个分支上，这样做可以使提交历史更加整洁；而合并是把最终结果合在一起。</span><br><span class="line"></span><br><span class="line">提取某次提交中引入的补丁和修改，然后在当前分支的基础上应用一次，这种操作就叫做rebase。</span><br><span class="line"></span><br><span class="line">rebase后的提交历史如图6，merge提交历史如图7，同样的提交，使用merge和rebase的区别一目了然。</span><br><span class="line"></span><br><span class="line">你可以自由选择`rebase`或`merge`，不过如果你选择`rebase`的话，请记住只对尚未推送或分享给别人的提交进行`rebase`操作。</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/internetWei/images/raw/master/uPic/%E6%88%AA%E5%B1%8F2021-08-03%2010.45.35.png"> 图6</p><p><img src="https://gitee.com/internetWei/images/raw/master/uPic/%E6%88%AA%E5%B1%8F2021-08-03%2010.49.53.png"> 图7</p><ul><li><p><code>git rebase &lt;分支&gt;</code> 将当前分支上的提交依次变基到目标分支上</p></li><li><p><code>git rebase &lt;分支1&gt; &lt;分支2&gt;</code> 将分支2上的提交依次变基到分支1上</p><blockquote><p>示例：</p><p><code>git rebase master experiment</code> 将experiment分支上的提交内容依次变基到master分支上，如图8</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0b1bc478bd2f48d5a25d5b886ec99f8d~tplv-k3u1fbpfcp-zoom-1.image"> 图8</p><p>切换到master分支再合并experiment分支就不会有分叉的提交历史了，如图9</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6518e127a0e446b8b790c21f620f7c26~tplv-k3u1fbpfcp-zoom-1.image"> 图9</p><blockquote><p>rebase的原理：</p><ol><li><p>首先找到这2个分支的最近共同祖先C2</p></li><li><p>然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件</p></li><li><p>然后将当前分支指向目标基底C3</p></li><li><p>最后以此将之前保存的临时文件的修改依次应用</p></li></ol></blockquote></blockquote></li><li><p><code>git rebase --onto &lt;分支1&gt; &lt;分支2&gt; &lt;分支3&gt;</code> 找到分支3在分支2分歧后的提交，然后把这些提交在分支1上依次应用一遍</p><blockquote><p>示例：</p><p><code>git rebase --onto master server client</code> 找到client分支，找出它从server分支分歧之后的提交，然后把这些提交在master分支上重放一遍，如图10所示</p></blockquote><p>  <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/567d0c68f2854ef08fa29313a8ecaee7~tplv-k3u1fbpfcp-zoom-1.image"> 图10</p></li><li><p><code>git rebase -i &lt;区间&gt;</code> 对指定区间内的提交进行交互式变基</p><blockquote><p>示例：</p><p><code>git rebase -i HEAD~2</code> 对最近3次提交进行交互式变基，交互式变基的功能非常强大，可以实现“将任意提交压缩成一个提交”、“将一个提交拆成多个提交”、“修改任意提交的提交说明”、“重新排序”、“移除提交”等功能</p></blockquote></li><li><p><code>git commit --amend</code> 修改最新的提交信息</p><blockquote><p>虽然它是commit开头的命令，不过它的本质就是rebase操作，所以把它放在rebase里</p><p>该命令有2个作用：</p><ol><li><p>修改最新的提交说明；确保当前暂存区是干净的，然后运行此命令，它会将你带到提交说明编辑框，重新编辑提交信息然后保存退出即可。</p></li><li><p>补充提交文件；例如上次提交时忘记添加一个文件，或者上次提交的文件又有修改了，而这次修改应该和上次提交是一起的；首先将需要补充提交的文件添加到暂存区，确保暂存区的文件是你要补充提交的，然后运行此命令，编辑提交信息保存退出即可。</p></li></ol></blockquote></li><li><p><code>git cherry-pick &lt;commit&gt;</code> 将指定提交的修改在当前分支的基础上重放一遍并提交</p></li></ul><h4 id="Git-Remote"><a href="#Git-Remote" class="headerlink" title="Git Remote"></a>Git Remote</h4><ul><li><p><code>git remote</code> 显示所有远程仓库的名称</p><blockquote><p><code>-v</code> 显示远程仓库的具体信息</p><p><code>show &lt;仓库名&gt;</code> 显示指定远程仓库的详细信息</p><p><code>ls-remote &lt;仓库名&gt;</code> 显示指定远程仓库的完整引用列表</p><p><code>prune &lt;仓库名&gt;</code> 删除本地镜像仓库存在但远程已删除的分支信息</p><p><code>git remote set-url &lt;仓库名&gt; &lt;url&gt;</code> 修改指定仓库的地址  </p></blockquote></li><li><p><code>git fetch &lt;仓库名&gt;</code> 拉取指定仓库的信息并更新本地的仓库信息(这只会更新本地的远程镜像仓库，不会修改本地分支和工作区内容)</p></li><li><p><code>git pull</code> 拉取上游分支的新提交并合并，它是<code>fetch</code>和<code>merge</code>2个命令的缩写</p><blockquote><p>pull 命令需要该分支拥有上游分支，如果没有上游分支会提示错误信息，它会运行<code>git fetch</code>将远程仓库的信息拉取下来，然后运行<code>git merge</code>合并远程的提交</p></blockquote></li><li><p><code>git branch -u(--set-upstream-to) &lt;远程分支引用&gt;</code> 设置&#x2F;修改当前分支的上游分支引用</p><blockquote><p><code>git branch -u origin/dev</code> 设置&#x2F;修改当前分支的上游分支为origin仓库的dev分支</p><p>当某个分支拥有上游分支后，可以使用{u(upstream)}代替上游分支</p></blockquote></li><li><p><code>git push</code> 将当前分支的新提交推送到上游分支</p><blockquote><p><code>git push origin refs/head/dev:refs/head/dev</code> 这是推送命令的全称，将本地dev分支推送到远程dev分支上</p><p><code>git push origin v1.0</code> 推送指定标签到远程仓库(默认推送并不会推送标签)</p><p><code>git push origin --tags</code> 推送所有标签到远程仓库</p><p><code>git push origin --delete dev</code> 删除远程仓库的dev分支</p><p><code>git push origin --delete v1.0</code> 删除远程仓库的v1.0分支</p><p><code>git push origin --delete</code>命令实际是<code>git push origin :refs/head/dev</code>，推送一个空对象覆盖远程仓库的dev分支(这么做只是从服务器上移除一个指针，Git通常会将数据保存一段时间直到垃圾回收机制运行。</p></blockquote></li></ul><h4 id="Git-Tag"><a href="#Git-Tag" class="headerlink" title="Git Tag"></a>Git Tag</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tag和Branch的区别：</span><br><span class="line"></span><br><span class="line">相同点：都是一个指向commit对象的指针</span><br><span class="line"></span><br><span class="line">不同点：Tag的位置是固定的，永远指向一个具体的commit对象。而Branch会随着分支的提交或回滚变化位置。</span><br><span class="line"></span><br><span class="line">轻量Tag和附注Tag的区别：</span><br><span class="line"></span><br><span class="line">轻量Tag就像一个不会改变的分支，它只是某个特定提交的引用；而附注Tag则是一个完整的Git对象，它包含打标签者的相关信息、打标签的时间、打标签的说明，还支持GPG签名和验证。</span><br></pre></td></tr></table></figure><ul><li><p><code>git tag &lt;标签名&gt;</code> 给当前提交创建一个轻量Tag</p><blockquote><p><code>-a</code> 创建一个附注Tag</p><p><code>&lt;hash&gt;</code> 尾随一个哈希值，可以给指定提交创建Tag</p><p><code>-s</code> 使用GPG对标签进行签名</p><p><code>-l(--list) &quot;v1.*&quot;</code> 显示所有以”v1.”开头的标签，支持正则匹配</p><p><code>-v</code> 使用GPG验证签名(前提是签名者的公钥需要在你的钥匙链中)</p></blockquote></li></ul><h4 id="Git-Branch"><a href="#Git-Branch" class="headerlink" title="Git Branch"></a>Git Branch</h4><ul><li><p><code>git branch</code> 显示所有本地分支</p><blockquote><p><code>-v</code> 显示分支对应的最新提交</p><p><code>-vv</code> 显示分支与上游分支的落后&#x2F;领先情况</p><p><code>-merged</code> 显示与当前分支已合并的分支</p><p><code>--no-merged</code> 显示与当前分支未合并的分支</p></blockquote></li></ul><h4 id="Git-Merge"><a href="#Git-Merge" class="headerlink" title="Git Merge"></a>Git Merge</h4><ul><li><p><code>git merge &lt;分支名&gt;</code> 合并指定分支</p><blockquote><p><code>--squash</code> 将合并产生的多个提交压缩成一个提交</p><p><code>--verify-signature</code> 拒绝合并那些GPG签名验证不通过的提交</p><p><code>-Xignore-space-change</code> 将一个空白符与多个连续的空白字符视作等价</p><p><code>-Xignore-all-space</code> 合并时完全忽略空白修改</p><p><code>-Xours</code> 遇到冲突时保留当前分支的修改内容</p><p><code>-Xtheirs</code> 遇到冲突时保留目标分支的修改内容  </p></blockquote></li><li><p><code>git merge-base &lt;分支1&gt; &lt;分支2&gt;</code> 获取2个分支最近的公共提交</p></li><li><p><code>git merge --verity-signature -S &lt;分支名&gt;</code> 生成一个签名的合并提交</p></li><li><p><code>git merge -s ours &lt;分支名&gt;</code> 做一次假的合并，记录一个以两边分支作为父结点的新合并提交，但是它甚至根本不关注你正合并入的分支，它只会简单地把当前分支的代码当作合并结果记录下来</p><blockquote><p>假如你有一个分叉的release分支并且在上面做了一些你想要在未来某个时候合并回master的工作，与此同时master分支上的某些bugfix需要向后移植回release分支，你可以合并bugfix分支进入release分支同时也merge -s ours 合并进入你的master分支(即使那个修复已经在那里了)这样当你之后再次合并release分支时，就不会有来自bugfix的冲突。</p></blockquote></li></ul><h4 id="Git-邮箱工作"><a href="#Git-邮箱工作" class="headerlink" title="Git 邮箱工作"></a>Git 邮箱工作</h4><ul><li><p><code>git format-patch -M &lt;分支名&gt;</code> 生成当前分支和指定分支之间不共有的提交补丁文件到根目录下(有几个提交就会生成几个补丁文件)</p><blockquote><p>示例：</p><p><code>git format-patch -M origin/master</code> 生成当前分支和origin&#x2F;master分支之间不共有的提交补丁文件到根目录下(这会生成一份可以邮寄的mbox格式的文件，它将每一个提交转换为一封电子邮件)。<code>-M</code>表示允许Git检查是否有对文件重命名的提交</p></blockquote></li><li><p><code>git apply --check &lt;path&gt;</code> 检查指定路径下的补丁内容是否可以被应用</p></li><li><p><code>git apply &lt;path&gt;</code> 应用指定路径下的补丁内容</p></li><li><p><code>git am &lt;path&gt;</code> 和<code>git apply</code>功能类似，不过比它更智能</p><blockquote><p><code>--resolved</code> 继续应用下一个补丁</p><p><code>-3</code> 表示当应用补丁发生冲突时Git会尝试进行三方合并，该选项默认是关闭的</p><p><code>am</code>的含义：应用(Apply)一系列来自邮箱(Mailbox)的补丁</p><p><code>git apply</code>用于应用<code>git diff</code>或<code>Unix diff</code>命令创建的补丁，它和<code>patch -p1</code>命令几乎是等效的，但是<code>git apply</code>更加严格，相对于<code>patch</code>来说它能够接受的模糊匹配更少，<code>git apply</code>采用了一种”要么全部应用，要么就全部撤销”的模型，即补丁只有全部内容都被应用和全部不被应用两种状态，如果补丁是用<code>git format-patch</code>来创建的，那么建议使用<code>git am</code>来应用补丁，只有对老式的补丁，你才必须使用<code>git apply</code></p></blockquote></li></ul><h4 id="Git-Rerere"><a href="#Git-Rerere" class="headerlink" title="Git Rerere"></a>Git Rerere</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Rerere是“重用已记录的冲突解决方案”的意思，它是一种简化冲突解决的方法，当启动rerere时，Git会维护一些成功合并之前和之后的镜像，当Git发现之前已经修复过类似的冲突时，便会使用之前的修复方案而不需要你的干预</span><br></pre></td></tr></table></figure><ul><li><p><code>git config --global rerere.enabled true</code> 启用Rerere功能</p><blockquote><p>对于已经创建的仓库如果想启动Rerere功能，需要手动在.git文件夹下创建一个rr-cache文件夹</p><p>开启Rerere后会增加本地仓库的体积，rr-cache文件夹只存在于本地仓库，不会推送到远程  </p></blockquote></li><li><p><code>git checkout --conflict=merge &lt;path&gt;</code> 将指定文件恢复到Rerere执行前的状态</p></li></ul><h4 id="Git-归档"><a href="#Git-归档" class="headerlink" title="Git 归档"></a>Git 归档</h4><ul><li><p><code>git archive &lt;commit&gt; --prefix=&#39;&lt;解压后的文件名&gt;/&#39; | gzip &gt; &lt;压缩包的名称&gt;.tar.gz</code> 基于指定提交对象创建一个当前所有快照内容的压缩文件</p><blockquote><p>示例：</p><p><code>git archive master --prefix=&#39;project/&#39; &gt; gzip &gt; master.tar.gz</code> 基于master最新提交的所有快照内容创建一个tar.gz压缩文件</p><p>git archive master –prefix&#x3D;’project&#x2F;‘ –format&#x3D;zip &gt; `git describe master`.zip 基于master最新提交的所有快照内容创建一个zip压缩文件  </p></blockquote></li><li><p><code>git bundle</code> 对分支进行打包</p><blockquote><p>示例：</p><p><code>git bundle create repo.bundle HEAD master</code> 对master分支的所有提交历史进行打包  </p></blockquote></li><li><p><code>git bundle verify &lt;path&gt;</code> 检查指定bundle包是否合法</p></li><li><p><code>git bundle list-heads &lt;path&gt;</code> 列出指定bundle包的引用</p></li></ul><h4 id="Git-Stash"><a href="#Git-Stash" class="headerlink" title="Git Stash"></a>Git Stash</h4><ul><li><p><code>git stash</code> 贮藏所有已跟踪的未提交文件，并还原暂存区和工作区的修改变化</p><blockquote><p><code>-u(--include-untracked)</code> 贮藏所有已跟踪和未跟踪的文件(不包括忽略文件)</p><p><code>-a(--all)</code> 贮藏所有文件(包括忽略文件)</p><p><code>--keep-index</code> 保存到贮藏的同时不清空暂存区的内容</p><p><code>list</code> 查看所有贮藏文件列表</p><p><code>apply</code> 恢复最新的贮藏文件但不删除，可以指定某个贮藏文件</p><p><code>pop</code> 和apply命令一样但是会自动删除贮藏文件(仅在恢复成功时自动删除)</p><p><code>--index</code> 如果在<code>pop</code>和<code>apply</code>时加上此选项会把贮藏前在暂存区的内容重新加到暂存区中，默认全部恢复在工作区  </p></blockquote></li><li><p><code>git stash &lt;贮藏文件&gt; &lt;分支名&gt;</code> 使用指定贮藏文件创建一个分支</p></li></ul><h4 id="Git-Add"><a href="#Git-Add" class="headerlink" title="Git Add"></a>Git Add</h4><ul><li><p><code>git add</code> 将文件加入到暂存区中</p><blockquote><p><code>-i(--interactive)</code> 使用交互式终端模式进行暂存</p><p><code>-p(--patch)</code> 自定义暂存补丁文件(该命令只是-i的一个子命令)</p></blockquote></li></ul><h4 id="Git-Commit"><a href="#Git-Commit" class="headerlink" title="Git Commit"></a>Git Commit</h4><ul><li><p><code>git commit</code> 将暂存区的文件提交到Git仓库</p><blockquote><p><code>-S</code> 使用GPG签名此次提交</p><p><code>-m &quot;注释&quot;</code> 使用指定注释作为提交内容</p><p><code>-a</code> 将已跟踪的所有文件加入到暂存区(未跟踪的文件不会加入到暂存区)</p><p><code>-am</code> -a和-m这2个命令的缩写</p></blockquote></li></ul><h4 id="Git-搜索"><a href="#Git-搜索" class="headerlink" title="Git 搜索"></a>Git 搜索</h4><ul><li><p><code>git grep &lt;字符串&gt;</code> 在工作区中搜索指定字符串出现的所有位置</p><blockquote><p>示例：</p><p><code>git grep --break --heading -n -e &#39;#define&#39; --and \( -e kEncryptionSecret -e kEncryptionKey \) v4.6.0</code> 查看在v4.6.0标签的Git代码库中定义了常量名包含”kEncryptionSecret”或”kEncryptionKey”这两个字符串的位置</p><p><code>-n(--line-number)</code> 显示在文件中的行数</p><p><code>-c(--count)</code> 显示在文件中匹配的数量</p><p><code>-p(--show-function)</code> 显示该字符串上下文内容</p></blockquote></li></ul><h4 id="Git-Subtree"><a href="#Git-Subtree" class="headerlink" title="Git Subtree"></a>Git Subtree</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这里没有提到 git submodule(子模块)，因为使用子模块相比Subtree更麻烦，例如在有子模块的仓库中切换分支需要重新初始化一下子模块，git subtree可以实现git submodule的功能，并且比git submodule更简单。</span><br></pre></td></tr></table></figure><ul><li><p><code>git subtree add --prefix=&lt;path&gt; &lt;link&gt; &lt;分支名&gt;</code> 添加指定仓库下的指定分支内容到指定路径下</p><blockquote><p>示例：</p><p><code>git subtree add --prefix=sub/libpng &lt;link&gt; master</code> 拉取指定仓库下master分支到sub&#x2F;libpng文件夹下  </p></blockquote></li><li><p><code>git subtree pull --prefix=&lt;path&gt; &lt;link&gt; &lt;分支名&gt;</code> 拉取子树的修改提交</p></li><li><p><code>git subtree push --prefix=&lt;path&gt; &lt;link&gt; &lt;分支名&gt;</code> 推送子树的修改提交</p></li></ul><h4 id="Git-Filter"><a href="#Git-Filter" class="headerlink" title="Git Filter"></a>Git Filter</h4><ul><li><p><code>git filter-branch</code> 重写提交历史</p><blockquote><p>示例：</p><p><code>git filter-branch --tree-filter &#39;rm -f password.txt&#39; HEAD</code> 从Git仓库中删除password.txt，–tree-filter表示检出项目的每一个提交后运行指定的命令然后重新提交结果，如果要让上述命令在所有分支上运行，可以加上–all</p><p><code>git filter-branch --subdirectory-filter trunk HEAD</code> 将trunk子目录设置为项目的根目录，Git会自动移除所有不影响子目录的提交</p></blockquote>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git filter-branch --commit-filter &#x27;</span><br><span class="line">if [ &quot;$GIT_AUTHOR_EMAIL&quot; = &quot;internetwei@foxmail.com&quot; ];</span><br><span class="line">then</span><br><span class="line">        GIT_AUTHOR_NAME=&quot;Scott Chacon&quot;;</span><br><span class="line">        GIT_AUTHOR_EMAIL=&quot;schacon@example.com&quot;;</span><br><span class="line">        git commit-tree &quot;$@&quot;;</span><br><span class="line">else</span><br><span class="line">        git commit-tree &quot;$@&quot;;</span><br><span class="line">fi&#x27; HEAD </span><br><span class="line"></span><br><span class="line">遍历所有提交，如果作者邮件地址是internetwei@foxmail.com则修改作者名称和邮件地址(即使某个提交不用修改但是它的哈希值也会更改)</span><br></pre></td></tr></table></figure></li><li><p><code>git filter-repo</code> 重写提交历史</p><blockquote><p>Git官方建议使用git filter-repo而不是git filter-branch，因为git filter-branch在重写提交历史时充满大量的陷阱，性能也很低，它的设计架构在接口的每一层都存在泄漏，这使得它几乎不可能在不向后兼容的情况下更改设计的任何内容。相比较而言git filter-repo的功能更多，而且性能也高出很多(有资料说用git filter-repo几个小时完成的任务用git filter-branch需要等待3个月)。</p><p><code>git filter-repo --path-rename &lt;old_name:new_name&gt;</code> 遍历提交历史，将作者名从old_name修改为new_name</p><p><code>--tag-rename &lt;old_tag:new_tag&gt;</code> 遍历提交历史，重命名以old开头的标签并以new开头，例如<code>--tag-rename foo:bar</code>会将foo-1.2改为bar-1.2</p><p>想学习git filter-repo请查看<a href="https://htmlpreview.github.io/?https://github.com/newren/git-filter-repo/blob/docs/html/git-filter-repo.html">git filter-repo命令手册</a></p></blockquote></li></ul><h4 id="Git-Show"><a href="#Git-Show" class="headerlink" title="Git Show"></a>Git Show</h4><ul><li><p><code>git show &lt;分支名&gt;@&#123;yesterday&#125;</code> 查看指定分支在昨天的最后一次提交对象</p><blockquote><p>yesterday可以是其他任意Git可以识别的时间  </p></blockquote></li><li><p><code>git show &lt;commit&gt;:&lt;path&gt;</code> 查看指定提交下指定文件的内容</p></li></ul><h4 id="Git-Reset"><a href="#Git-Reset" class="headerlink" title="Git Reset"></a>Git Reset</h4><ul><li><p><code>git reset --soft &lt;commit&gt;</code> 将当前分支移动到指定提交上(这样做会导致Git仓库和暂存区与工作区的内容不一致，而暂存区和工作区的内容一致，所以Git会提示你进行commit操作和Git仓库保持一致)，如图11。</p><p>   <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/646fd8d8cf5941a1a2a3bbd2c140423c~tplv-k3u1fbpfcp-zoom-1.image"> 图11</p></li><li><p><code>git reset --mixed &lt;commit&gt;</code> 默认行为，将当前分支移动到指定提交上并且更新暂存区的内容(这样做会导致Git仓库和暂存区的内容一致，但是和工作区的内容不一致，这时Git会提交你进行add操作将需要提交的文件添加到暂存区)，如图12</p><p>   <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aefb6b8501144712b39ccb51ad152e54~tplv-k3u1fbpfcp-zoom-1.image"> 图12</p></li><li><p><code>git reset --hard &lt;commit&gt;</code> 将当前分支移动到指定提交上并且更新暂存区和工作区的内容，这也是reset唯一危险的命令(这样做Git会使用版本库中的内容更新(覆盖)暂存区和工作区的内容)，如图13</p><p>   <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/63c1aeeafb13499885b805f05815048a~tplv-k3u1fbpfcp-zoom-1.image"> 图13</p></li><li><p><code>git reset &lt;path&gt;</code> 将指定文件从暂存区中删除</p><blockquote><p>它本质上调用的是<code>git reset --mixed HEAD &lt;path&gt;</code>命令，使用版本库中的指定文件覆盖暂存区的文件，所以它可以将文件从暂存区中移除</p></blockquote></li></ul><h4 id="Git-Checkout"><a href="#Git-Checkout" class="headerlink" title="Git Checkout"></a>Git Checkout</h4><ul><li><p><code>git checkout -b &lt;分支名&gt;</code> 创建并切换到指定分支</p><blockquote><p>该命令其实是<code>git branch &lt;分支名&gt;</code>和<code>git checkout &lt;分支名&gt;</code>的缩写</p><p>切换分支建议使用<code>git switch &lt;分支名&gt;</code>，一是因为switch比checkout更容易理解，二是因为switch命令比checkout命令更安全(例如本地有一个文件名和某一个分支同名，当你使用git checkout &lt;文件&#x2F;分支名&gt; 时可能会不小心覆盖工作区的内容)</p></blockquote></li><li><p><code>git checkout -- &lt;path&gt;</code> 撤销工作区指定文件的修改</p><blockquote><p>该命令会使用当前版本库中的指定文件覆盖工作区的指定文件，如果工作区的文件有任何修改将会丢失</p></blockquote></li></ul><h4 id="Git-Revert"><a href="#Git-Revert" class="headerlink" title="Git Revert"></a>Git Revert</h4><ul><li><p><code>git revert &lt;commit&gt;</code> 还原指定提交的内容</p><blockquote><p>该命令用于将某次提交的内容重置并生成一次新提交</p></blockquote></li></ul><h4 id="Git-Blame"><a href="#Git-Blame" class="headerlink" title="Git Blame"></a>Git Blame</h4><ul><li><p><code>git blame -L &lt;range&gt; &lt;path&gt;</code> 查看指定文件中指定范围内的修改提交记录</p><blockquote><p>示例：</p><p><code>git blame -L 68,100 WXYZ_BookReaderViewController.m</code> 查看WXYZ_BookReaderViewController.m文件有关第68到100行的修改提交记录</p><p><code>-C</code> 该选项表示Git会分析你正在标注的文件，并且尝试找出文件中代码片段的原始出处</p></blockquote></li></ul><h4 id="Git-Bisect"><a href="#Git-Bisect" class="headerlink" title="Git Bisect"></a>Git Bisect</h4><ul><li><p><code>git bisect</code> 使用二分搜索查找引入错误的提交</p><blockquote><p>使用流程：</p><p><code>git bisect start</code> 启动二分查找</p><p><code>git bisect bad</code> 告诉Git当前提交是有问题的</p><p><code>git bisect good &lt;commit&gt;</code> 告诉Git没有问题的提交是哪一次</p><p><code>git bisect good</code> 告诉Git当前提交没有问题</p><p><code>git bisect reset</code> 结束二分查找</p><p><code>git biesect start &lt;bad_id&gt; &lt;good_id&gt;</code> 快速执行二分查找，第一个参数是不正常的提交，第二个参数是正常的提交</p><p><code>git bisect run &lt;path&gt;</code> 执行脚本进行二分查找</p></blockquote></li></ul><h4 id="Git-Replace"><a href="#Git-Replace" class="headerlink" title="Git Replace"></a>Git Replace</h4><ul><li><p><code>git replace</code> 替换指定对象</p><blockquote><p><code>git replace &lt;commit1&gt; &lt;commit2&gt;</code> 将commit1替换为commit2</p></blockquote></li></ul><h4 id="Git-底层命令"><a href="#Git-底层命令" class="headerlink" title="Git 底层命令"></a>Git 底层命令</h4><ul><li><p><code>git ls-files</code> 显示有关索引和工作树中文件的信息</p><blockquote><p><code>-u(--unmerged)</code> 显示冲突对象的哈希值</p><p><code>-s(--stage)</code> 显示暂存区当前状态  </p></blockquote></li><li><p><code>git rev-list</code> 按时间倒序列出提交对象</p><blockquote><p><code>--count &lt;分支名&gt;</code> 查看指定分支的提交数量  </p></blockquote></li><li><p><code>git cat-file</code> 查看指定对象的内容或类型和大小信息</p><blockquote><p><code>-p</code> 获取指定对象的内容或类型信息</p><p><code>-t</code> 获取指定对象的类型</p><p><code>-s</code> 获取指定对象的大小  </p></blockquote></li><li><p><code>git ls-tree</code> 列出树对象的内容</p><blockquote><p><code>-r</code> 递归子树对象下的内容  </p></blockquote></li><li><p><code>git update-ref</code> 更新存储在ref中的对象名称</p><blockquote><p>示例：</p><p><code>git update-ref refs/tags/v1.0 c7cfb9</code> 给指定提交对象添加一个轻量标签  </p></blockquote></li><li><p><code>git count-objects -v</code> 查看仓库的详细占用空间</p></li><li><p><code>git for-each-ref</code> 显示所有的引用</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Objc风格指南</title>
      <link href="/2021/08/07/Objc%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97/"/>
      <url>/2021/08/07/Objc%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<!-- > 由布多(budo)发布于 2023年10月26日 • 最后更新：2023年10月29日 --> <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>制定风格指南主要的目的是统一团队的代码风格与样式，提高工作效率与阅读性还有维护性；<br>这篇文章虽然是OC风格指南，但是有些风格是所有编程语言通用的，另外它还参考了<a href="https://github.com/alibaba/Alibaba-Java-Coding-Guidelines">阿里巴巴Java代码规范</a>，想不到吧。</p><h2 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h2><h4 id="优化阅读体验，而非写代码的体验"><a href="#优化阅读体验，而非写代码的体验" class="headerlink" title="优化阅读体验，而非写代码的体验"></a>优化阅读体验，而非写代码的体验</h4><p>&nbsp;&nbsp;&nbsp; 代码库通常具有较长的生命周期，并且花在阅读代码上的时间也远多于编写代码的时间。所以我们应该明确一个目标：去优化别人阅读、维护我们代码时的体验，而不是优化写代码时的体验(<code>例如随便使用缩写进行编码，代码量变少了，但是增加了阅读和维护的难度</code>)。</p><p>&nbsp;&nbsp;&nbsp; 适当的规范限制和标准不是消灭代码内容的创造性、优雅性，而是限制过度个性化，以一种普遍认可的方式一起做事，进而提高工作效率，降低沟通成本。提高稳定性。</p><h4 id="与上下文尽量保持一致"><a href="#与上下文尽量保持一致" class="headerlink" title="与上下文尽量保持一致"></a>与上下文尽量保持一致</h4><p>&nbsp;&nbsp;&nbsp; 尽量保持代码库中的风格样式一致。在整个代码库中始终保持一种风格可以让工程师更专注于其他(更重要的)问题。一致性还可以实现更好的自动化。</p><p>&nbsp;&nbsp;&nbsp; 如果风格指南中没有说明，那么就按照代码库之前的风格样式或者参考 <code>Apple SDK</code> 的风格样式。</p><h2 id="命名风格"><a href="#命名风格" class="headerlink" title="命名风格"></a>命名风格</h2><h4 id="通用命名风格"><a href="#通用命名风格" class="headerlink" title="通用命名风格"></a>通用命名风格</h4><ul><li><p><strong>[必须]</strong> 清晰和简洁(<code>好的名称应该是能自我描述的</code>)，简洁的原则是为了保持更好的清晰度和可读性，记住 <strong>不要本末倒置</strong>。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">// 移除一个对象。</span><br><span class="line">1. removeObject:</span><br><span class="line">// 使用指定字符串替换出现过的字符串。</span><br><span class="line">2. stringByReplacingOccurrencesOfString: withString:</span><br><span class="line"></span><br><span class="line">反例：</span><br><span class="line">// 要移除什么？</span><br><span class="line">1. remove:</span><br><span class="line">// 要将什么替换成什么？是全部都替换还是只替换第一个匹配的位置？</span><br><span class="line">2. replace(&quot;1&quot;, &quot;2&quot;)</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 一致性：命名应该和上下文乃至全局保持一致性，相同类型或者具有相同作用方法的名称应该相同或类似。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">1. NSDictionary、NSArray、NSSet这些类中名叫 count 的方法所体现的作用都是一样的。</span><br><span class="line">2. 系统的一些代理方法和通知的名称也会刻意保持一致，</span><br><span class="line">   例如 `UIApplicationDelegate`协议中的 `applicationDidBecomeActive` 方法名</span><br><span class="line">   就和 `UIApplicationDidBecomeActiveNotification`通知的名称是一致的。</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 禁止自我指涉：命名不要自我指涉(通知、掩码或常量等除外)。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">NSString</span><br><span class="line"></span><br><span class="line">反例：</span><br><span class="line">NSStringObject</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 禁止过度缩写和自创缩写，一些通用缩写名除外(例如ATM、GPS、max、min等)，具体请参考 <a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CodingGuidelines/Articles/APIAbbreviations.html#//apple_ref/doc/uid/20001285-BCIHCGAE">可接受的缩写词列表</a>。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tips:</span><br><span class="line">阅读者可能来自不同的地方接受不同的教育和不同的文化，</span><br><span class="line">他们不一定会明白你写的缩写的意思。</span><br><span class="line"></span><br><span class="line">正例：</span><br><span class="line">setBackgroundColor</span><br><span class="line"></span><br><span class="line">反例：</span><br><span class="line">setBgColor</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 禁止使用无意义的拼音，国际通用名、地名、人名除外。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">Beijing、Alibaba</span><br><span class="line"></span><br><span class="line">反例：</span><br><span class="line">// 打折</span><br><span class="line">DaZhePromotion</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 代码和注释中避免使用任何语言的种族歧视性词语。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">secondary、main</span><br><span class="line"></span><br><span class="line">反例：</span><br><span class="line">slave、master</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 禁止以new、alloc、copy、mutableCopy等关键字作为名称的开始部分。</p></li><li><p><strong>[必须]</strong> 由于 <strong>OC</strong> 没有命名空间的概念，所以全局名称(<code>类名、协议名、全局常量名、全局变量名、函数名、typedef名称</code>)必须添加前缀，前缀由3个及以上字符组成且全部大写。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tips: </span><br><span class="line">由于系统保留任意两个字符作为前缀的使用权(NS、UI、CG、CF、CA、WK、MK、CI、NC等等)，</span><br><span class="line">为了避免和系统命名冲突，所以前缀至少由3个字符组成。</span><br><span class="line"></span><br><span class="line">正例：</span><br><span class="line">ZTYLoginViewController</span><br><span class="line"></span><br><span class="line">反例：</span><br><span class="line">ZTLoginViewController</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 如果某个全局名称(<code>例如函数名、通知名、协议方法名</code>)和某个类有所关联，那么请使用相关类名作为其前缀，否则请使用通用前缀。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">UIApplicationDidBecomeActiveNotification</span><br><span class="line">MAGUserLoginSuccessNotification</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 命名风格统一使用 <strong>驼峰命名方式</strong> ，局部变量名等特殊名称可以不遵守。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">totalRemain</span><br><span class="line"></span><br><span class="line">反例：</span><br><span class="line">total_remain</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 成员变量名称必须以_作为开始部分。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">_nameString</span><br><span class="line"></span><br><span class="line">反例：</span><br><span class="line">nameString</span><br></pre></td></tr></table></figure></li><li><p><strong>[建议]</strong> 在给常量或变量命名时，请将表示类型的名词放在词尾，以提高辨识度。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">nameLabel、nameString</span><br><span class="line"></span><br><span class="line">反例：</span><br><span class="line">name</span><br></pre></td></tr></table></figure></li><li><p><strong>[建议]</strong> 如果模块、接口、类、方法使用了某种模式，在命名时尽量体现出具体模式。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">OrderFactory、LoginProxy</span><br></pre></td></tr></table></figure></li><li><p><strong>[建议]</strong> 建议给临时变量名称添加前缀，以提高辨识度(<code>特殊情况除外，例如for循环里面的i</code>)。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">// t表示temp</span><br><span class="line">t_label</span><br><span class="line"></span><br><span class="line">反例：</span><br><span class="line">label</span><br></pre></td></tr></table></figure></li></ul><h4 id="类名风格"><a href="#类名风格" class="headerlink" title="类名风格"></a>类名风格</h4><ul><li><p><strong>[必须]</strong> 一个完整的类名由 <strong>前缀+名称+类型</strong> 3个部分组成。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">MAGLoginViewControler</span><br><span class="line"></span><br><span class="line">前缀：MAG</span><br><span class="line">名称：Login</span><br><span class="line">类型：ViewControler</span><br></pre></td></tr></table></figure></li></ul><h4 id="分类命名风格"><a href="#分类命名风格" class="headerlink" title="分类命名风格"></a>分类命名风格</h4><ul><li><p><strong>[必须]</strong> 分类命名风格和类名类似，由 <strong>前缀+名称</strong> 2个部分组成。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">UIView (MAGAdd)</span><br><span class="line"></span><br><span class="line">反例：</span><br><span class="line">UIView (Add)</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 分类中的方法名必须要添加前缀，防止覆盖系统或3方库的私有方法，前缀需要保持唯一性(<code>例如mp_</code>)。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">mp_substringFromString</span><br><span class="line"></span><br><span class="line">反例：</span><br><span class="line">substringFromString</span><br></pre></td></tr></table></figure></li><li><p><strong>[建议]</strong> 分类中建议不要声明属性，尽量挪到主类中声明。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tips: </span><br><span class="line">尽管从技术上来讲可以在分类中声明属性，但是这么做需要格外小心，</span><br><span class="line">因为它很容易出现内存上或其他一些问题，而且出现问题很难排查。</span><br></pre></td></tr></table></figure></li><li><p><strong>[建议]</strong> 如果一个类比较复杂，建议使用分类重新组织结构和代码(<code>可以参考系统的UIView</code>)。</p></li></ul><h4 id="枚举命名风格"><a href="#枚举命名风格" class="headerlink" title="枚举命名风格"></a>枚举命名风格</h4><ul><li><p><strong>[必须]</strong> 枚举名称的前缀应该和 <strong>typedef</strong> 的名称保持一致。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">typedef NS_ENUM(NSInteger, MGradientChangeDirection) &#123;</span><br><span class="line">    MGradientChangeDirectionLevel,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">反例：</span><br><span class="line">typedef NS_ENUM(NSInteger, MGradientChangeDirection) &#123;</span><br><span class="line">    level,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="方法命名风格"><a href="#方法命名风格" class="headerlink" title="方法命名风格"></a>方法命名风格</h4><ul><li><p><strong>[必须]</strong> 方法名称的开头一般以小写字母开始，特殊单词除外(<code>例如HTTP、URL</code>)。</p></li><li><p><strong>[必须]</strong> 方法名称禁止直接使用_作为开始部分。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tips: </span><br><span class="line">由于系统的私有方法通常以_作为开始部分，这么做可以避免不小心覆盖系统私有方法。</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 私有方法必须添加前缀，前缀需要保持唯一性(<code>例如mp_</code>)。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tips: </span><br><span class="line">给私有方法添加前缀有如下好处：</span><br><span class="line">1. 提高辨识度，提高代码可读性。</span><br><span class="line">2. 避免不小心覆盖系统或框架的私有方法。</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 如果方法返回某个属性值，那么请直接使用属性名作为方法名。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">- (CGSize)cellSize;</span><br><span class="line"></span><br><span class="line">反例：</span><br><span class="line">- (CGSize)getCellSize;</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 方法的每个参数前必须添加有效关键字。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">- (void)sendAction:(SEL)aSelector </span><br><span class="line">          toObject:(id)anObject </span><br><span class="line">       forAllCells:(BOOL)flag;</span><br><span class="line">       </span><br><span class="line">反例：</span><br><span class="line">- (void)sendAction:(SEL)aSelector </span><br><span class="line">                  :(id)anObject </span><br><span class="line">                  :(BOOL)flag;</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 如果某个方法是由通知触发的，那么请使用 <code>Notification</code> 关键字作为名称后缀。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">appDidBecomeActiveNotification</span><br><span class="line"></span><br><span class="line">反例：</span><br><span class="line">appDidBecomeActive</span><br></pre></td></tr></table></figure></li><li><p><strong>[建议]</strong> 尽量不要使用“and”连接接收者属性，尽管and读起来还算顺口，但随着你创建的方法参数的增加，这将会带来一系列的问题。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">- (int)runModalForDirectory:(NSString *)path </span><br><span class="line">                       file:(NSString *)name </span><br><span class="line">                      types:(NSArray *)fileTypes;</span><br><span class="line">                      </span><br><span class="line">反例：</span><br><span class="line">- (int)runModalForDirectory:(NSString *)path </span><br><span class="line">                    andFile:(NSString *)name </span><br><span class="line">                   andTypes:(NSArray *)fileTypes;</span><br></pre></td></tr></table></figure></li><li><p><strong>[建议]</strong> 如果方法描述了两个独立的动作，则可以使用 <code>and</code> 连接。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">- (BOOL)openFile:(NSString *)fullPath </span><br><span class="line"> withApplication:(NSString *)appName </span><br><span class="line">   andDeactivate:(BOOL)flag;</span><br></pre></td></tr></table></figure></li><li><p><strong>[建议]</strong> 尽量不要使用 <code>get</code> 作为方法名称的开始部分，除非这个方法间接返回对象或值。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">- (UIColor *)backgroundColor;</span><br><span class="line">- (void)getLineDash:(float *)pattern count:(int *)count phase:(float *)phase;</span><br><span class="line"></span><br><span class="line">反例：</span><br><span class="line">- (UIColor *)getBackgroundColor;</span><br></pre></td></tr></table></figure></li></ul><h4 id="协议命名风格"><a href="#协议命名风格" class="headerlink" title="协议命名风格"></a>协议命名风格</h4><ul><li><p><strong>[必须]</strong> 协议中的方法名以触发消息的对象名开头，省略类名前缀并首字母小写，如果它没有关联任何类则可以忽略这个规则。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">- (BOOL)tableView:(NSTableView *)tableView </span><br><span class="line">  shouldSelectRow:(int)row;</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 除非协议方法只有一个参数，否则冒号需紧跟在类名后面。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">1. - (BOOL)tableView:(NSTableView *)tableView </span><br><span class="line">     shouldSelectRow:(int)row;</span><br><span class="line">  </span><br><span class="line">2. - (BOOL)applicationOpenUntitledFile:(NSApplication *)sender;</span><br></pre></td></tr></table></figure></li></ul><h4 id="通知命名风格"><a href="#通知命名风格" class="headerlink" title="通知命名风格"></a>通知命名风格</h4><ul><li><p><strong>[必须]</strong> 一个完整的通知名称由 <strong>关联的类名&#x2F;通用前缀+名称+Notification</strong> 3个部分组成。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">UIApplicationDidBecomeActiveNotification</span><br><span class="line"></span><br><span class="line">关联的类：UIApplication</span><br><span class="line">通知名称：DidBecomeActive</span><br><span class="line">固定后缀：Notification</span><br></pre></td></tr></table></figure></li></ul><h4 id="常量命名风格"><a href="#常量命名风格" class="headerlink" title="常量命名风格"></a>常量命名风格</h4><ul><li><p><strong>[必须]</strong> 如果常量局限于某个 <strong>编译单元</strong>(<code>通常指某个类的实现文件内</code>) 之内，通常在前面加小写字母k作为前缀，若常量在全局可见，通常以类名作为前缀，然后采用首字母大写驼峰命名方式。</p>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">// 局部可见</span><br><span class="line">const CGFloat kAnimationDuration = 2.0;</span><br><span class="line">// 全局可见</span><br><span class="line">const CGFloat UIActivityIndicatorViewAnimationDuration = 2.0;</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> const如果修饰的是基本数据类型，则放在最左侧，如果修饰的是对象，则放在变量名前面。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">const NSInteger age</span><br><span class="line">NSString * const name</span><br></pre></td></tr></table></figure></li></ul><h4 id="异常类命名风格"><a href="#异常类命名风格" class="headerlink" title="异常类命名风格"></a>异常类命名风格</h4><ul><li><strong>[必须]</strong> 一个完整的异常类名称由 <strong>前缀+名称+Exception</strong> 3个部分组成。</li></ul><h4 id="文件命名风格"><a href="#文件命名风格" class="headerlink" title="文件命名风格"></a>文件命名风格</h4><ul><li><p><strong>[必须]</strong> 文件名全部小写，使用_连接不同的模块，模块中的单词可以使用驼峰命名。</p></li><li><p><strong>[必须]</strong> 文件名称由 <strong>所属模块+描述</strong> 2个部分组成。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">public_back@2x.png</span><br></pre></td></tr></table></figure></li></ul><h4 id="注释风格"><a href="#注释风格" class="headerlink" title="注释风格"></a>注释风格</h4><ul><li><p><strong>[必须]</strong> 注释请遵守 <a href="https://www.doxygen.nl/index.html">Doxygen</a> 风格。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一个好的例子：</span><br><span class="line">/**</span><br><span class="line"> * @brief 关于这个方法的一个简短说明。</span><br><span class="line"> * @discussion 一段详细的描述。</span><br><span class="line"> * @warning 一些警告信息。</span><br><span class="line"> * @note 描述一些需要注意的事情。</span><br><span class="line"> * @param obj1 参数1的说明。</span><br><span class="line"> * @return 返回值的说明。</span><br><span class="line"> * @code</span><br><span class="line"> * 示例代码：</span><br><span class="line"> * id temp = [self testFunction:@&quot;111&quot;];</span><br><span class="line"> * @endcode</span><br><span class="line"> *</span><br><span class="line"> * @par 分割线，上面是一些常用的注释语法，下面是不常用的注释语法。</span><br><span class="line"> *</span><br><span class="line"> * @todo 即将要做的事情。</span><br><span class="line"> * @bug 可能存在的BUG，或者对缺陷的说明。</span><br><span class="line"> * @since 说明从什么版本、什么时间加入此代码。</span><br><span class="line"> * @exception 对可能存在的异常的解释。</span><br><span class="line"> * @pre 用来说明执行方法所需要的前提条件。</span><br><span class="line"> * @post 用来说明执行方法之后的使用条件。</span><br><span class="line"> * @author 作者名称。</span><br><span class="line"> * @remark 一些评论信息。</span><br><span class="line"> * @copyright 版权信息。</span><br><span class="line"> * @version 当前的工程版本。</span><br><span class="line"> * @par 一个新的名称</span><br><span class="line"> *</span><br><span class="line"> * 开始一个新段落。</span><br><span class="line"> */</span><br><span class="line">- (id)testFunction:(NSString *)obj1 &#123;</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  效果图<br>  <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f01e7d9511334d728efdf822fe013f79~tplv-k3u1fbpfcp-zoom-1.image" alt="图片"></p></li><li><p><strong>[必须]</strong> 注释的作用是用于解释那些复杂不容易理解的逻辑，以及需要注意的地方，而不是告诉别人这个方法的作用，作用应该在名称中体现出来，提供一个合理的名称比使用晦涩的名称然后试图通过注释来解释它们要好的多。</p></li><li><p><strong>[必须]</strong> 如果修改了实现细节，请记得修改注释。</p></li><li><p><strong>[必须]</strong> 注释不要写的太冗长或太简短，这样都不利于别人快速理解。</p></li><li><p><strong>[必须]</strong> 注释的双斜线和内容之间有且仅有一个空格。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">// 这是示例注释，请注意在双斜线后有一个空格。</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 注释中的语句也需要添加适量的标点符号和空格帮助别人理解。</p></li><li><p><strong>[必须]</strong> 对于代码注释需要谨慎，代码被注释一般有2种可能，1. 后续会恢复此段代码逻辑； 2. 永久不用；对于第1种情况需添加相应注释，如果没有注释信息难以知晓注释动机，后者建议直接删除。如果有需要可以通过代码仓库查阅历史代码。</p></li><li><p><strong>[必须]</strong> 如果某个方法是有问题的，可以使用特殊注释来提醒别人和自己。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">// MARK: - 方法集</span><br><span class="line">// TODO: 等待实现</span><br><span class="line">// FIXME: 有bug，需要修改</span><br><span class="line">// !!!: 逻辑混乱，需要完善</span><br><span class="line">// ???: 具体干什么用的？</span><br><span class="line">- (void)testFunction;</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 行尾注解和代码保持2个空格，如果后续行有多个注释，将它们排列起来通常会更具可读性。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例:</span><br><span class="line">[self doSomethingWithALongName];  // Two spaces before the comment.</span><br><span class="line">[self doSomethingShort];          // More spacing to align the comment.</span><br></pre></td></tr></table></figure></li><li><p><strong>[建议]</strong> 别给糟糕的代码加注释，重构它。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tips: </span><br><span class="line">注释不能美化糟糕的代码。当企图使用注释前，先考虑是否可以通过调整结构，命名等操作，消除写注释的必要。</span><br></pre></td></tr></table></figure></li><li><p><strong>[建议]</strong> 如果一个类比较复杂或者有需要注意的地方，那么请在声明它的地方加上注释帮助别人快速理解，如果有必要可以使用 <a href="https://wwi.lanzout.com/iyHlYz0lxqf"><strong>Monodraw</strong></a> 工具绘制ASCII图形提高可读性，如下图所示。</p><p>  monodraw示例图(这张图很清楚的向别人表达这个类的作用)<br>  <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/63b45029f3684dfba4de6f7b4a6e8a8a~tplv-k3u1fbpfcp-zoom-1.image" alt="monodraw示例图"></p></li></ul><h2 id="编码风格"><a href="#编码风格" class="headerlink" title="编码风格"></a>编码风格</h2><ul><li><p><strong>[必须]</strong> 不要增加多余空格来使上下代码的等号对齐。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">int a1 = 1;</span><br><span class="line">long a2 = 3;</span><br><span class="line">NSString *a3 = @&quot;&quot;;</span><br><span class="line"></span><br><span class="line">反例：</span><br><span class="line">int a1       = 1;</span><br><span class="line">long a2      = 3;</span><br><span class="line">NSString *a3 = @&quot;&quot;;</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 逗号(,)后面、二元运算符的左右应该添加1个空格，小括号左右不要有空格。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">kColorRGB(255, 255, 255);</span><br><span class="line">int a = 3 + 4;</span><br><span class="line"></span><br><span class="line">反例：</span><br><span class="line">kColorRGB(255,255,255)</span><br><span class="line">int a = 3+4;</span><br></pre></td></tr></table></figure></li><li><p><strong>[建议]</strong> 尽量使用 if return 代替 if else，if 嵌套最好不超过5层。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">if (x == 1) &#123;</span><br><span class="line">……</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (x == 2) &#123;</span><br><span class="line">……</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">反例：</span><br><span class="line">if (x == 1) &#123;</span><br><span class="line">……</span><br><span class="line">&#125; else if (x == 2) &#123;</span><br><span class="line">……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>[建议]</strong> 尽量避免采用取反逻辑运算符，因为取反逻辑不利于快速理解。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">if (array == nil) &#123;</span><br><span class="line">……</span><br><span class="line">&#125;</span><br><span class="line">反例：</span><br><span class="line">if (!array) &#123;</span><br><span class="line">……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="结构风格"><a href="#结构风格" class="headerlink" title="结构风格"></a>结构风格</h2><ul><li><p><strong>[必须]</strong> 文件内部使用的常量、静态变量在@interface之前声明，如果没有@interface就在@implementation前声明。</p></li><li><p><strong>[必须]</strong> 同一类型的属性声明放在一块显示，中间用一行空格区分，不同类型的声明用2行空格隔开，属性声明的开始和末尾都要添加一行空格。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">@interface MineViewController ()</span><br><span class="line"></span><br><span class="line">@property (nonatomic, weak) UIView *headView;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, weak) UITableView *tableView;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy) NSArray *dataSourceArray;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 不同作用的方法按照顺序进行排序，生命周期相关的方法 &gt; 公开方法 &gt; 私有方法 &gt; 继承方法 &gt; 通知方法 &gt; 协议方法 &gt; getter&#x2F;setter方法，简单的说就是越重要越常用的方法越靠前。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#pragma mark - LifeCycle(生命周期相关的代码放在最上面)</span><br><span class="line">- (void)dealloc &#123;&#125;</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;&#125;</span><br><span class="line"></span><br><span class="line">- (void)viewWillAppear:(BOOL)animated &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#pragma mark - Public(公开方法)</span><br><span class="line">// code...</span><br><span class="line">// 下空两行</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#pragma mark - Private(私有方法)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#pragma mark - Override(需要覆盖父类的方法)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#pragma mark - Notification(通知方法)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#pragma mark - Delegate(Delegate需要实现的方法)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#pragma mark - Getter/Setter</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 方法的声明顺序应该为类方法 &gt; 初始化方法 &gt; 实例方法。</p></li><li><p><strong>[建议]</strong> 不同逻辑、不同语义、不同业务的代码之间插入一个空行分隔开以提升可读性。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例:</span><br><span class="line">[self createSubviews];</span><br><span class="line">[self createTableview];</span><br><span class="line"></span><br><span class="line">[self netRequest];</span><br></pre></td></tr></table></figure></li><li><p><strong>[建议]</strong> 头文件包含顺序应该是系统头文件 &gt; SDK头文件 &gt; 其他依赖的头文件，用一个空行分隔逻辑上不同的头文件，在每个组中，包含的内容建议按首字母顺序排列。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例:</span><br><span class="line">#import &quot;ProjectX/BazViewController.h&quot;</span><br><span class="line"></span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">#include &quot;base/basictypes.h&quot;</span><br><span class="line">#include &quot;base/integral_types.h&quot;</span><br><span class="line">#include &quot;util/math/mathutil.h&quot;</span><br><span class="line"></span><br><span class="line">#import &quot;ProjectX/BazModel.h&quot;</span><br><span class="line">#import &quot;Shared/Util/Foo.h&quot;</span><br></pre></td></tr></table></figure></li></ul><h4 id="一个好的头文件例子："><a href="#一个好的头文件例子：" class="headerlink" title="一个好的头文件例子："></a>一个好的头文件例子：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line"></span><br><span class="line">#import &quot;WXYZ_ADDefine.h&quot;</span><br><span class="line">    </span><br><span class="line">@class WXYZ_ADModel;</span><br><span class="line">    </span><br><span class="line">NS_ASSUME_NONNULL_BEGIN</span><br><span class="line">    </span><br><span class="line">/// 提供给外部使用的广告实例对象，所有需要使用广告的地方都应该使用 WXYZ_ADView 创建。</span><br><span class="line">@interface WXYZ_ADView : UIView</span><br><span class="line">    </span><br><span class="line">/// 广告相关属性，key表示广告标题，value表示广告宽度。</span><br><span class="line">@property(nonatomic, copy) NSDictionary&lt;NSString *, NSNumber *&gt; *attributes;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">/// 根据广告类型和广告位置返回是否一个布尔值，表示是否需要展示广告。</span><br><span class="line">+ (BOOL)canLoadADWithADType:(WXYZ_ADViewType)adType adPosition:(WXYZ_ADViewPosition)adPosition;</span><br><span class="line">    </span><br><span class="line">/// 根据广告类型和广告位置创建并返回一个adView对象。</span><br><span class="line">/// @discussion 如果广告开关是关闭状态则返回nil。</span><br><span class="line">/// @param adType 广告类型</span><br><span class="line">/// @param adPosition 广告位置</span><br><span class="line">+ (nullable instancetype)createADViewWithType:(WXYZ_ADViewType)adType adPosition:(WXYZ_ADViewPosition)adPosition;</span><br><span class="line">    </span><br><span class="line">/// 设置adModel将会更新正在显示的广告内容。</span><br><span class="line">- (void)setAdModel:(WXYZ_ADModel *)adModel;</span><br><span class="line">    </span><br><span class="line">+ (instancetype)allocWithZone:(struct _NSZone *)zone UNAVAILABLE_ATTRIBUTE;</span><br><span class="line">    </span><br><span class="line">+ (instancetype)new UNAVAILABLE_ATTRIBUTE;</span><br><span class="line">    </span><br><span class="line">+ (instancetype)alloc UNAVAILABLE_ATTRIBUTE;</span><br><span class="line">    </span><br><span class="line">- (instancetype)initWithFrame:(CGRect)frame UNAVAILABLE_ATTRIBUTE;</span><br><span class="line">    </span><br><span class="line">- (instancetype)init UNAVAILABLE_ATTRIBUTE;</span><br><span class="line">    </span><br><span class="line">@end</span><br><span class="line">    </span><br><span class="line">NS_ASSUME_NONNULL_END</span><br></pre></td></tr></table></figure><ol><li>使用 <strong>@class</strong> 向前声明 <code>WXYZ_ADModel</code>而不是用 <code>#import</code>包含。</li><li>@interface 之前有关于类的说明注释，帮助别人在使用这个类时快速了解这个类的作用以及需要注意的地方。</li><li>字典使用了泛型声明字典包含的类型，并且在注释中详细的说明了字典包含的内容。</li><li>属性和第一个方法之间有2个空格来区分它们没有关联性。</li><li>每个属性和返回值都有是否为空的状态，例如 <code>+ createADViewWithType</code> 方法使用 <code>nullable</code> 表明了返回值可能为空的状态，并且在注释中说明了什么情况下会返回空对象。</li><li>遵守了类方法 &gt; 初始化方法 &gt; 实例方法的规则。</li></ol><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><ol><li>可以转载，但是请注明来源。</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CodingGuidelines/CodingGuidelines.html">Cocoa编码规范</a></li><li><a href="https://github.com/alibaba/Alibaba-Java-Coding-Guidelines">阿里巴巴Java代码规范</a></li><li><a href="https://book.douban.com/subject/25829244/">Effective Objective-C 2.0  编写高质量iOS与OS X代码的52个有效方法</a></li><li><a href="https://google.github.io/styleguide/objcguide.html">Google的Objective-C风格指南</a></li><li>网上发布的有关代码规范的文章</li></ol>]]></content>
      
      
      <categories>
          
          <category> 代码人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Objc </tag>
            
            <tag> 代码规范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown语法备忘录</title>
      <link href="/2021/03/08/Markdown%E8%AF%AD%E6%B3%95%E5%A4%87%E5%BF%98%E5%BD%95/"/>
      <url>/2021/03/08/Markdown%E8%AF%AD%E6%B3%95%E5%A4%87%E5%BF%98%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p>由布多发布于 2021年03月08日 • 最后更新：2023年12月26日</p></blockquote><p>这不是一篇教你如何入门 Markdown 语法的文章，它存在的目的是记录我们平常不经常使用的语法，例如如何调整图片的宽度信息；由于这些语法我们不经常使用，所以到用时总是会忘记，此时就需要一篇文章来记录这些不常用的语法，需要用到但又忘记的时候打开来看一下即可。</p><p>基于这个原则，文章不会有如何声明标题这样的语法。</p><blockquote><p>注意：文章中用到了很多 HTML 语法，某些平台可能不支持这些语法。</p></blockquote><hr><h3 id="多行段落"><a href="#多行段落" class="headerlink" title="多行段落"></a>多行段落</h3><p>默认情况下多行空白内容只会显示一行；可以使用 <code>&lt;br&gt;&lt;/br&gt;</code> 实现多行效果。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一行</span><br><span class="line"></span><br><span class="line">&lt;br&gt;&lt;/br&gt;</span><br><span class="line">&lt;br&gt;&lt;/br&gt;</span><br><span class="line">第二行</span><br></pre></td></tr></table></figure><p>第一行</p><p><br></br><br><br></br><br>第二行</p><h3 id="单行注释"><a href="#单行注释" class="headerlink" title="单行注释"></a>单行注释</h3><p>由于是注释内容，所以你看不到实际内容，这是正常现象(<code>如果你看到了实际内容，说明该平台不支持该语法</code>)。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[//]: 这是一行注释</span><br></pre></td></tr></table></figure><h3 id="多行注释"><a href="#多行注释" class="headerlink" title="多行注释"></a>多行注释</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">我是第一行注释，</span><br><span class="line">我是第二行注释。</span><br><span class="line">--&gt;</span><br></pre></td></tr></table></figure><!--我是第一行注释，我是第二行注释。--><h3 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h3><p><span id="anchor1">默认情况下</span>多个空格只会显示为一个空格，可以使用 <code>&amp;nbsp;</code> 实现多个空格的效果。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">文字1 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;文字2</span><br></pre></td></tr></table></figure><p>文字1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;文字2</p><h3 id="链接的悬停文案"><a href="#链接的悬停文案" class="headerlink" title="链接的悬停文案"></a>链接的悬停文案</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[百度](https://www.baidu.com &quot;当鼠标悬停在文字上方时，你会看到它&quot;)</span><br></pre></td></tr></table></figure><p><a href="https://www.baidu.com/" title="当鼠标悬停在文字上方时，你会看到它">百度</a>(<code>ps: 把鼠标悬停在「百度」上，你能看到悬停文案</code>)</p><h3 id="图片的悬停文案"><a href="#图片的悬停文案" class="headerlink" title="图片的悬停文案"></a>图片的悬停文案</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">![阿西河图片](https://p.upyun.com/docs/cloud/demo.jpg &quot;当鼠标悬停在文字上方时，你会看到它&quot;)</span><br></pre></td></tr></table></figure><p><img src="https://p.upyun.com/docs/cloud/demo.jpg" alt="阿西河图片" title="当鼠标悬停在文字上方时，你会看到它"></p><h3 id="图片自定义对齐方式和尺寸等参数"><a href="#图片自定义对齐方式和尺寸等参数" class="headerlink" title="图片自定义对齐方式和尺寸等参数"></a>图片自定义对齐方式和尺寸等参数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div style=&quot;text-align: center;background-color: #b6ffc8;&quot;&gt;</span><br><span class="line">    &lt;img </span><br><span class="line">        src=&quot;https://p.upyun.com/docs/cloud/demo.jpg&quot; </span><br><span class="line">        alt=&quot;阿西河图片&quot; </span><br><span class="line">        title=&quot;阿西河图片Title&quot; </span><br><span class="line">        style=&quot;width:300px;height:300px;&quot;</span><br><span class="line">    &gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><div style="text-align: center;background-color: #b6ffc8;">    <img         src="https://p.upyun.com/docs/cloud/demo.jpg"         alt="阿西河图片"         title="阿西河图片Title"         style="width:300px;height:300px;"    ></div><h3 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">```c</span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    printf(&quot;Hello World!&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">```</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大部分语言的关键字都是其名称的小写形式，例如 JavaScript 对应的关键字是 javascript，固而我只记录了一些特殊的关键字：</p><table><thead><tr><th align="center">语言名</th><th align="center">关键字</th></tr></thead><tbody><tr><td align="center">C++</td><td align="center">cpp</td></tr><tr><td align="center">c#</td><td align="center">cs</td></tr><tr><td align="center">Objective-C</td><td align="center">objc</td></tr></tbody></table><h3 id="跳转到指定标题"><a href="#跳转到指定标题" class="headerlink" title="跳转到指定标题"></a>跳转到指定标题</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[点击跳转到「多行段落」标题](#多行段落)</span><br></pre></td></tr></table></figure><p><a href="#%E5%A4%9A%E8%A1%8C%E6%AE%B5%E8%90%BD">点击跳转到「多行段落」标题</a></p><h3 id="跳转到指定文案"><a href="#跳转到指定文案" class="headerlink" title="跳转到指定文案"></a>跳转到指定文案</h3><p>要跳转处的文案必须这样写：<code>&lt;span id=&quot;anchor1&quot;&gt;默认情况下&lt;/span&gt;</code>。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[点击跳转到指定位置「默认情况下」](#anchor1)</span><br></pre></td></tr></table></figure><p><a href="#anchor1">点击跳转到指定位置「默认情况下」</a></p><h3 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">脚注1[^1]</span><br></pre></td></tr></table></figure><p>脚注1 <a href="%E8%84%9A%E6%B3%A81">^1</a></p><h3 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- [x] 已完成的任务</span><br><span class="line">- [ ] 未完成的任务</span><br></pre></td></tr></table></figure><ul><li><input checked="" disabled="" type="checkbox"> 已完成的任务</li><li><input disabled="" type="checkbox"> 未完成的任务</li></ul><h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这是 ~~删除线~~</span><br></pre></td></tr></table></figure><p>这是 <del>删除线</del></p><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;font face=&quot;黑体&quot; size=5&gt;我是黑体字&lt;/font&gt;</span><br><span class="line">&lt;font face=&quot;微软雅黑&quot; size=5&gt;我是微软雅黑&lt;/font&gt;</span><br></pre></td></tr></table></figure><p><font face="黑体" size=5>我是黑体字</font><br><font face="微软雅黑" size=5>我是微软雅黑</font></p><h3 id="文字颜色"><a href="#文字颜色" class="headerlink" title="文字颜色"></a>文字颜色</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;font color=#0099ff&gt;我的文字颜色是蓝色&lt;/font&gt;</span><br></pre></td></tr></table></figure><p><font color=#0099ff>我的文字颜色是蓝色</font></p><h3 id="上标"><a href="#上标" class="headerlink" title="上标"></a>上标</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">n&lt;sup&gt;2&lt;/sup&gt; = n * n</span><br></pre></td></tr></table></figure><p>n<sup>2</sup> &#x3D; n * n</p><h3 id="下标"><a href="#下标" class="headerlink" title="下标"></a>下标</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">H&lt;sub&gt;2&lt;/sub&gt;O</span><br></pre></td></tr></table></figure><p>H<sub>2</sub>O</p><h3 id="背景颜色"><a href="#背景颜色" class="headerlink" title="背景颜色"></a>背景颜色</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;p style=&quot;background-color: #b6ffc8;&quot;&gt;&lt;font color=#000&gt;背景是绿色&lt;/font&gt;&lt;/p&gt;</span><br></pre></td></tr></table></figure><p style="background-color: #b6ffc8;"><font color=#000>背景是绿色</font></p><h3 id="文字对齐方式"><a href="#文字对齐方式" class="headerlink" title="文字对齐方式"></a>文字对齐方式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;p style=&quot;text-align: left;background-color: #b6ffc8;&quot;&gt;&lt;font color=#000&gt;文字左对齐&lt;/font&gt;&lt;/p&gt;</span><br><span class="line">&lt;p style=&quot;text-align: center;background-color: #b6ffc8;&quot;&gt;&lt;font color=#000&gt;文字居中对齐&lt;/font&gt;&lt;/p&gt;</span><br><span class="line">&lt;p style=&quot;text-align: right;background-color: #b6ffc8;&quot;&gt;&lt;font color=#000&gt;文字右对齐&lt;/font&gt;&lt;/p&gt;</span><br></pre></td></tr></table></figure><p style="text-align: left;background-color: #b6ffc8;"><font color=#000>文字左对齐</font></p><p style="text-align: center;background-color: #b6ffc8;"><font color=#000>文字居中对齐</font></p><p style="text-align: right;background-color: #b6ffc8;"><font color=#000>文字右对齐</font></p><h3 id="插入音频"><a href="#插入音频" class="headerlink" title="插入音频"></a>插入音频</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;iframe </span><br><span class="line">    frameborder=&quot;no&quot; </span><br><span class="line">    border=&quot;0&quot; </span><br><span class="line">    marginwidth=&quot;0&quot; </span><br><span class="line">    marginheight=&quot;0&quot; </span><br><span class="line">    width=100% </span><br><span class="line">    height=auto </span><br><span class="line">    src=&quot;https://music.163.com/outchain/player?type=2&amp;id=528478901&amp;auto=1&amp;height=66&quot;&gt;</span><br><span class="line">&lt;/iframe&gt;</span><br></pre></td></tr></table></figure><iframe     frameborder="no"     border="0"     marginwidth="0"     marginheight="0"     width=100%     height=auto     src="https://music.163.com/outchain/player?type=2&id=528478901&auto=1&height=66"></iframe><h3 id="插入视频"><a href="#插入视频" class="headerlink" title="插入视频"></a>插入视频</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;iframe </span><br><span class="line">    src=&quot;https://player.bilibili.com/player.html?aid=10631344&amp;cid=17548810&amp;page=1&quot; </span><br><span class="line">    scrolling=&quot;no&quot; </span><br><span class="line">    style=&quot;border:0;width:100%;height:auto;min-height:790px;&quot;</span><br><span class="line">    allowfullscreen=&quot;true&quot;&gt; </span><br><span class="line">&lt;/iframe&gt;</span><br></pre></td></tr></table></figure><iframe     src="https://player.bilibili.com/player.html?aid=10631344&cid=17548810&page=1"     scrolling="no"     style="border:0;width:100%;height:auto;min-height:790px;"    allowfullscreen="true"> </iframe><h3 id="使用Mermaid画图"><a href="#使用Mermaid画图" class="headerlink" title="使用Mermaid画图"></a>使用Mermaid画图</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">```mermaid</span><br><span class="line">sequenceDiagram</span><br><span class="line">    participant Alice</span><br><span class="line">    participant Bob</span><br><span class="line">    Alice-&gt;John: Hello John, how are you?</span><br><span class="line">    loop Healthcheck</span><br><span class="line">        John-&gt;John: Fight against hypochondria</span><br><span class="line">    end</span><br><span class="line">    Note right of John: Rational thoughts &lt;br/&gt;prevail...</span><br><span class="line">    John--&gt;Alice: Great!</span><br><span class="line">    John-&gt;Bob: How about you?</span><br><span class="line">    Bob--&gt;John: Jolly good!</span><br><span class="line">```</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    participant Alice</span><br><span class="line">    participant Bob</span><br><span class="line">    Alice-&gt;John: Hello John, how are you?</span><br><span class="line">    loop Healthcheck</span><br><span class="line">        John-&gt;John: Fight against hypochondria</span><br><span class="line">    end</span><br><span class="line">    Note right of John: Rational thoughts &lt;br/&gt;prevail...</span><br><span class="line">    John--&gt;Alice: Great!</span><br><span class="line">    John-&gt;Bob: How about you?</span><br><span class="line">    Bob--&gt;John: Jolly good!</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LLDynamicLaunchScreen的设计思路</title>
      <link href="/2021/03/07/LLDynamicLaunchScreen%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF/"/>
      <url>/2021/03/07/LLDynamicLaunchScreen%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<!-- > 由布多(budo)发布于 2023年10月26日 • 最后更新：2023年10月29日 --><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;动态修改iPhone上APP的启动图，将它修改为用户喜欢的图片，这样用户每次打开APP第一眼就可以看到自己喜欢的图片，这对于用户来说是不是挺爽呢。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;其实这个想法我很早之前就萌发了(大概是2019年上半年)，有一次我发现苹果提供了方法可以动态修改APP的Logo，就萌发了动态修改启动图的想法，当时查阅了一些资料，然后自己通过实践发现确实可以不更新APP动态修改启动图。不过因为当时公司的APP并不需要这个功能，而且大部分的软件厂商也并没有注意到这一块的用户体验，所有的APP也都不支持用户自定义启动图，所以当时也就没继续往下深究了。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;时间眨眼就来到了2020年下半年，当时因为公司的APP要实现暗黑模式，但是这个APP已经更新迭代了3年多，在所有页面添加修改色值的代码工作量太大，而且我们的APP支持iOS10但是系统的暗黑API最低支持iOS13，然后自己就写了一个暗黑框架<a href="https://github.com/internetWei/llDark">LLDark</a>，当APP集成好这个暗黑框架后，发现APP强行切换成一个模式后，APP的启动图却没有跟随APP的模式变化，而是跟随系统模式，简单的说就是APP强行设置成了浅色模式，但是系统是深色模式，当用户打开APP时启动图会显示深色(系统)的启动图而不是浅色(APP)的启动图。对于大部分的人来说可能觉得这个问题可以跳过，因为大部分的APP也都这样，但是我是一个完美主义者，为了能让用户有一个完美的体验，然后我就写了<a href="https://github.com/internetWei/LLDynamicLaunchScreen">LLDynamicLaunchScreen</a>，它最初的目的只是为了配合<a href="https://github.com/internetWei/llDark">LLDark</a>实现完美的暗黑模式，后面考虑到可能有APP注意到了这一块的用户体验想要实现动态修改启动图，所以就把它抽离出来并开源了<a href="https://github.com/internetWei/LLDynamicLaunchScreen">LLDynamicLaunchScreen</a>。</p><h3 id="关于启动图的坑"><a href="#关于启动图的坑" class="headerlink" title="关于启动图的坑"></a>关于启动图的坑</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;启动图莫名其妙变成黑色的这个BUG已经有很多APP遇到了，我公司的APP也遇到了，我手机上的微信也遇到了，基本可以确定是苹果的BUG。如图1.1(这是我在手机上录制的，录制时间为2021年3月7号)，大家可以发现我在打开微信APP时屏幕是一片黑色的，我拿同事的手机测试了发现他的手机打开微信APP启动图依旧是原来的一个地球和一个人，所以确定不是微信把启动图换成了黑色(同事手机上的微信版本和我手机上的微信版本是一致的，而且我们的系统版本号也一致)。</p><table><thead><tr><th align="center"><img src="https://gitee.com/internetWei/images/raw/master/uPic/202103061844.gif"></th></tr></thead><tbody><tr><td align="center">图1.1</td></tr></tbody></table><p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://github.com/internetWei/LLDynamicLaunchScreen">LLDynamicLaunchScreen</a>支持修复如上问题，您只需要将它集成到您的工程中即可，什么事情都不用做，图2.1这样的情况将可能不会出现在您的APP中，最坏的情况是用户第一次打开APP时可能会出现。</p><table><thead><tr><th align="center"><img src="https://gitee.com/internetWei/images/raw/master/uPic/202102141921.jpg"></th></tr></thead><tbody><tr><td align="center">图2.1</td></tr></tbody></table><h3 id="LLDynamicLaunchScreen介绍"><a href="#LLDynamicLaunchScreen介绍" class="headerlink" title="LLDynamicLaunchScreen介绍"></a>LLDynamicLaunchScreen介绍</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;<code>LLDynamicLaunchScreen</code>除了支持上述提到的自动修复启动图莫名其妙变成黑色的BUG，还支持运行时动态修改APP的任意启动图，仅需一行代码即可。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;目前市场上并没有和<code>LLDynamicLaunchScreen</code>类似的框架，github上有一个<code>DynamicLaunchImage</code>框架也实现了动态替换启动图的功能，但是我并不建议您使用它，具体原因我会在下面的对比中详细描述。</p><h3 id="关于LLDynamicLaunchScreen和DynamicLaunchImage"><a href="#关于LLDynamicLaunchScreen和DynamicLaunchImage" class="headerlink" title="关于LLDynamicLaunchScreen和DynamicLaunchImage"></a>关于LLDynamicLaunchScreen和DynamicLaunchImage</h3><ol><li><p><code>LLDynamicLaunchScreen</code>是我开发的一款用于修复iOS上APP启动图异常和动态修改启动图的框架，它实现了如下功能:</p><ol><li>集成后自动修复APP启动图异常显示。</li><li>集成者只需要一行代码即可修改启动图。</li><li>支持修改任意类型的启动图(暗黑竖屏启动图、暗黑横屏启动图、浅色竖屏启动图、浅色横屏启动图)。</li><li>当用户更新APP后自动恢复上一次设置的启动图。</li><li>支持获取当前显示的启动图和任意类型的启动图。</li></ol></li><li><p><code>DynamicLaunchImage</code>是百度团队开发的一款动态修改启动图的框架，它只实现了一个动态修改启动图的功能，而且当用户更新APP后，<code>DynamicLaunchImage</code>并没有记录用户上次的修改信息，它会导致用户更新版本后丢失之前设置的启动图，这是致命的；并且它也不支持单独修改暗黑系启动图或者单独修改浅色系启动图；最致命的是它的开发者并没有继续维护它，我提交了一个issues并没有人去跟进处理。所以建议您使用<a href="https://github.com/internetWei/LLDynamicLaunchScreen">LLDynamicLaunchScreen</a>。</p></li></ol><h3 id="LLDynamicLaunchScreen的具体思路"><a href="#LLDynamicLaunchScreen的具体思路" class="headerlink" title="LLDynamicLaunchScreen的具体思路"></a>LLDynamicLaunchScreen的具体思路</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;<code>LLDynamicLaunchScreen</code>它的核心功能其实就是替换系统本地的启动图，但是替换的过程中有如下的问题(只列举了一些比较重要的问题):</p><ol><li>替换系统本地的启动图但不能修改原名称，否则系统会重新生成启动图，这就需要知道本地的启动图名称对应的是哪个具体的启动图(例如本地启动图a.png代表的是深色竖屏启动图还是浅色坚屏启动图还是…)。</li><li>为了实现自动修复启动图异常，需要在APP启动后根据storyboard文件生成一整套的启动图文件并且替换本地的启动图，开发过程中遇到一个问题不管在什么时候生成与系统相反模式的启动图总是失败(例如当前系统是浅色模式，那么在生成深色启动图时实际获取到的总是浅色启动图)，后面通过KVO的思想解决了这个难题，具体思路是利用运行时创建一个自定义的<code>UIViewControler</code>对象并将它与系统的<code>UIViewController</code>的isa指针进行互换，然后监听它的<code>viewDidAppear:</code>方法的实现，在这个方法里再去生成启动图就可以了，当监听完成后会自动释放创建的对象然后将isa指针还原回去。</li><li>在iOS13以下的真机中没有启动图文件夹的读取和修改权限，针对这个问题确实愁了很多天，就在我想放弃iOS13以下系统可以动态修改启动图的想法前，我看到了<code>DynamicLaunchImage</code>的一篇实现文章，文章中提到它也遇到了这个问题，并且通过<code>moveItemAtPath: toPath: error:</code>这个方法解决了。经过测试发现确实可以变相的达到获取启动图信息并且替换启动图的功能，在这里感谢<code>DynamicLaunchImage</code>提供的思路。</li></ol><p>&nbsp;&nbsp;&nbsp;&nbsp;具体的实现细节大家可以阅读<a href="https://github.com/internetWei/LLDynamicLaunchScreen">LLDynamicLaunchScreen</a>源码，例如它是怎么在用户更新版本后自动还原至之前的设置。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;如果您有更好的意见或者发现有任何BUG，欢迎您提交<a href="https://github.com/internetWei/LLDynamicLaunchScreen/issues">issues</a>或者联系我。</p><h3 id="不足之处"><a href="#不足之处" class="headerlink" title="不足之处"></a>不足之处</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;由于iOS系统的限制，更新APP后第一次打开会显示默认启动图，之后才会显示自定义的启动图。另外它暂时对iPad的支持性不是很好，因为iPad有多达10种启动图样式，建议不要要iPad中使用它，后续我会升级它支持iPad。<code>LLDynamicLaunchScreen</code>它不支持非LaunchScreen配置的启动图(现在应该没有APP没有使用LaunchScreen适配启动图了吧)。</p><h3 id="LLDynamicLaunchScreen效果图"><a href="#LLDynamicLaunchScreen效果图" class="headerlink" title="LLDynamicLaunchScreen效果图"></a>LLDynamicLaunchScreen效果图</h3><table><thead><tr><th align="center"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/160c58e9014740029800c2ffc4752965~tplv-k3u1fbpfcp-zoom-1.image"></th></tr></thead><tbody><tr><td align="center"><a href="https://github.com/internetWei/LLDynamicLaunchScreen">LLDynamicLaunchScreen</a></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 移动开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Objc </tag>
            
            <tag> 开源框架 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
